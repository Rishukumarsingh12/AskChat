2025-07-11 02:44:13,452 - INFO - Transcript : hey guys Greg here let's talk about linked lists today and there's two types of them there's singly linked lists as well as doubly linked lists now in picture form a singly linked list might look something like this which is basically circles with values in them and then they point to other circles with the values so we have one pointing to two which points to three and the three actually points over to nothing and that's important because that kind of signifies here that this is the end of the list okay so we'd call this a singly linked list basically because there's this single connection here between the nodes later on we'll see a doubly link list that would basically just be this where we have the backwards link as well but this is called a singly linked list where basically each of these things generally you call them a linked list node or in short form you generally just call them a node so a node is like an object and it has a couple different features to it one it has some sort of memory address as to where it's located in the computer so this is not like an array where an array is like a contiguous sequence of computer memory this is not the case here we actually have this as some sort of address which is going to be some hex code it doesn't really matter what this is here just know that it's some memory address and I'll just kind of short form this to be a so it's the memory address of a and this one would have a completely different memory address likely even very far away in the computer memory of B and this one might be called C and this last thing here what it's pointing over to is generally in a programming language something like null so you might see it be called null in Python we generally have that called none whatever it is it's just some programming language specific that says a special marker saying this is the end of the list okay so what actually is a linked list node well in a computer programming language we have these things called classes okay and classes create these things called objects so basically you would have some sort of thing called like a class node object it would have a value as you can see here it clearly has a node. value we'll write it like that and it also has a node. next so node. next is basically a reference to a different object if we were talking about this guy here well then it would have a next of basically the address of B saying that its next address is pointing over to B and what that allows us to do if you have a its next is pointing over to B and its next is C and its next is none well then this forms a chain because we can basically start here generally you would have some sort of a reference to the head of the linked list which is going to be the front of it so given this reference to the head here well then we can basically go through the list here until we hit none now this is basically an alternative way to store data compared to say an array where an array has certain elements like if you were to ask what is the array at maybe an index of five well in O of one time that array would tell you what is at position five but that's not a thing for a linked list here you can't say what is at the index these things don't have indices generally what we're given is the head to the linked list and to find any of the different elements in here you'd actually have to Traverse the list to do that now by the way here we're storing just the values of 1 2 and three but you can pretty much store any type of data you want in one of those linked list nodes but for lead code style problems they generally just kind of have the numbers there okay so there's a few different things you might want to do with a linked list for example if you wanted to add a new node at an arbitrary positions so maybe add a node at the position of two for example well we don't really have positions here like an array but you could still think of it as this is say the first spot this is the second spot and the third spot and we'll say that we're adding the Noe of a value of five you'd have to start at your head because that's generally all that you're given you're not actually generally given a b and c here and so to add the node at position two you would have to Traverse the list from the start until you got to that position and then you could put that Noe in there you would want one to point over to the five so you'd have to change one to point that over to five and then you'd have to point the five over to the two a general and O of n operation because you have to start at the head of the linked list Traverse to get to that position and then you can adjust it now similarly if you wanted to instead delete a node at position 2 well then you'd have to start at the beginning pretty much like always and then you'd have to go through until you you get to that position and basically just remove it which would involve pointing the previous one over to the next one like that and then you could think of your positions as adjusted like this so 1 2 and three okay so again that's going to be an oent operation cuz you start at the beginning and go up until that position now even more simply if you wanted to just say access a node at a certain position so you didn't want to remove or add it you just wanted to kind of look what's there well again you'd kind of have to start at the beginning and go up until that position to kind of read that element so again an oent thing to do now an operation we generally perform on pretty much every single data structure that we have is lookup so in this case it would be seeing if a certain value is in the linked list okay so you could probably guess that's going to be an oent operation because in the worst case you would have to go through the entire list and have not found it or if you were looking up say something like two well then you would go through and see that two is there but still that's going to be an O of n thing to do now there is a couple things that are o of One op operations so one thing that linked lists are really good at is if you are talking about the beginning of the list so if you wanted to basically remove the thing at the beginning well then that is going to be an O of one operation because basically you would just kind of Point your head element over to this second position here so that would effectively just remove this and then you could think of your positions as one and two although I'm going to stop kind of writing the positions because they don't really exist if you wanted to add a new head so if all you wanted to do is kind of put some something at the very beginning well then yeah that's also going to be o of one you'd basically Point your head over to that new element and then you would Point your new element over to that one so that's also going to be o of one and if you particularly happen to have the reference to say the node here so maybe you happen to have node C over here and you wanted to say remove that what's kind of tricky about this is that if you just kind of remove this given access to node C well then how do you actually change where this node points to because it's sing linked list and so just given C you don't actually have the ability to adjust this one here you want to adjust this next pointer except you don't have that because you just have this node so that's why in practice a lot of the time we actually switch over to doubly link lists which is basically going to be the exact same thing here except we have the reverse connection and our head would actually Point reverse Direction over to none as well so basically saying we have a head element so we still have a head which I'm just going to Mark as h and we also kind of have access immediately to this tail so generally now instead of just access to the front you also have access to the back via the tail and we can kind of go both directions here you could Traverse through this way or you could Traverse backwards so this is a doubly linked list and by the way how this might look in a programming language is you might have a class node which is basically going to have three things now it would have basically a node do value so what it's storing it would have a no. next these are the exact same things as before but then you also might have a node. previous basically saying that each node here they all have a next pointer and they also have a previous pointer and sometimes I might say pointer sometimes I might say reference if you really truly want to understand the whole pointer thing then you'd want to take a class in C but from a python perspective it's basically just that node. nextext is like a reference to a node object and node. preve would be a reference to a node object as well now one thing the W link list does help with is if you had say a reference to this node here you had that if you wanted to delete that so basically if you wanted to delete node B well then you actually only need access to this node here because from this node you could actually access this one because you have the connection to it and you could also access this one so you could actually remove it because basically what you'd have to do is point this previous thing over to the next one and you'd have to point its next one basically back over to the previous one so this does allow basically deleting an element at a particular reference that would actually be constant although we often don't have that ability because generally you only have access to the head and the tail sometimes you have access to kind of the middle node references okay so let's see how we can work with singly and doubly linked lists in Python okay let's start with singly linked lists here so we need a class that makes a node we'll call it singly node and so for the Constructor here now they're going to take a value and they're going to take a next pointer so what it's pointing over to and by default this is just none or null okay and all the Constructor is going to do is just set that its value is the value passed in and the next pointer is the next passed in okay then we'll just give it a simple print method so we can print one of these that is the string method so underscore string like that and this just returns some sort of a string representation so this is going to be the string of the self. Val so we take whatever the V is we just convert that to a string and that's how this thing is going to print okay then to make a linked list you generally have reference only to the head so we'll call it head that's going to be a singly node which just has a value of one now by default this will make the next pointer just none but we'll set those explicitly in a moment we'll get three other nodes I'll call it a is the singly node of three and B is the singly node of four and C is the singly node of seven so we now have four different nodes where the head is one okay now to actually join these things up here by default we kind of just have these floating around in space we want to connect them up so head. next is equal to a points head over to a then a do next is equal to B and b. nextt is equal to C so now we have the connection of head points over to a which points over to B which points over to C and then C is still pointing over to nothing and for now we can just print the head of the list although that's not going to show the full list it's just going to show the value of the first node okay now one thing we usually want to do this is the most common pattern with length lists is some sort of Travers veral so in general just to Traverse the list print the values to Traverse the list this is going to be of course an O of n operation cuz we're visiting all the nodes then you generally get a variable called something like cerr and we'll point that at the head and we keep moving cerr over so while we have Curr so basically until cerr turns into none we will print the current node and then we are going to just move cerr over so we set cerr equal to c. next this effectively traverses cerr throughout the entire linked list until cerr hits the node of C then it's going to point to c. next which is null it'll end the while loop and so if we're just to run this here we'll see 1 3 47 so most linked list problems will be some sort of pattern where you Traverse the list now something that's going to prove very useful is being able to display it well so just basically displaying the linked list and this is going to take definitely o of n time we're going to call that a function display which takes a head so again we'll get a pointer or variable Curr is equal to the Head we'll build up a list of elements so elements is going to be a dynamic array or a list and then while we have Curr well we have one more element so we'd elements. append add that to the array we'll give it the string of the current Dov value and then we would just move C over so C is equal to c. next now after this Loop concludes we'd eventually have Curr is none and so what we want to do is print the string of the arrow like this and note the spaces so that it looks good do join up the elements so if you haven't seen join before basically what that would do do is given a list of strings so something like this A and B and C well join is going to move them into the string of just ABC but this thing here is what you kind of call a glue it's how it glues them together then when you join them it's going to kind of move them like this so it'll glue them together so it ends up looking like this so that's exactly what this does here if you display so display the original head that's going to show the link list very pretty like that okay now something you might want to do is search for a node so search sech for a node value and that's going to take o of n time so to do that we'll Define a function called search which again takes a head and it's also going to take a value to look for this pattern comes up all the time C is equal to head and then while we have C if the Val we're looking for is equal to the current value well then that means we found it and so we would return true if that wasn't the case then we need to keep looking so we set Cur equal to c. next and if this Loop ever concludes it means that we didn't find it and so we would return false at this level so let's just search for a few things here if we search for the value of two sorry you have to give that the head so search for head and two that is going to show up false we don't have that if you have nine that is also not the case if you have something that is in there like the head of one or the tail of seven clearly our search function works okay there's lots of exciting algorithms to learn about linked lists but you can learn those in the leak code problems okay now we're going to do doubly linked lists so for that again we'd have a class which is called doubly node so we have the forward and backward connection it takes a value that the node is going to be it takes a next pointer by default it's going to be none and it also has a previous which by default is going to be set to none okay then all it's going to do is just set the self. fou equal to the Past in fou and the next is going to be the next and the prieve is going to be the preve and we'll just give it a simple printing function so we'll Define underscore uncore string it's just going to return the string of the self. value the exact same as the previous okay then how we can work with this thing is you need access to both the head and the tail so we'll get head is equal to tail which is equal to a dou node and will give that the value of one if you print the head that should show you that the value is one and if you print the tail they're pointing to the same thing so this is also one so we'll Define a function call it display that takes just the head of the linked list you don't need the tail for this so we'll get Cur is equal to the head our elements is our list and again while we have cerr we want to elements. append the string of the C.V so exactly the same thing and we'd set c equal to c. next and then after we get out of here we just want to print with a different glue so we would print with the double connection like this implying we have forwards and backwards because we do so do join that up with the elements and if we were to run display just on our original head display the head we can see it's just one and that's totally accurate for now we just have one node so we want a function that inserts inserts at the beginning basically meaning getting a new head and that's going to be o of one so we'll Define a function called insert at beginning and that's going to take the head it's also going to take the tail and it's going to take the value that you want the new head to be so you would get a new node which is equal to a doubly node reference so we make a new node if you remember how our class looks here it is the value then next then previous so we want the value to be the value and we want to specifically specify that the next is equal to the head because it's saying that we're making a new node and we want that to be the value that we have we want this to point over to the Head the only thing we'd have to do here is set head. preve so our old head equal to the new node so before the head was basically pointing over to null because it was the head but now we want it to put in the middle pointing it to the new node we just made okay so we would return new node and the tail because this is our new head and the tail stay the same and then you would call this like with head and tail is equal to insert at beginning you'd give it the current head the current Tail as well as a new value and we'll give it the value of three so if we do that and then display our head well this is going to show that we have three at the beginning that made a new head and it points over to the one as the tail now if understanding this function was a little bit tricky that's the whole point of the lead code linked list problems is to get comfortable with drawing and then coding this idea okay similarly we could also do insert at end and I'm just kind of going to copy that and explain that for you we can insert at the end in O of one time where you give the head the tail and a new value you'd make a new node which is going to take that new value and you'd point that new node back over to the tail so that would point it left over to the old tail and then you would just need to update that your old tail is then going to point right over to your new node so this basically makes a new tail and so we'd return the head and the new tail and so if we were to run this with a value of seven we're going to see we have a new tail of seven okay as always you can get this code in the video description deson if you'd like to see it I hope this was helpful guys drop a like if it was and have a great day bye-bye
2025-07-11 02:44:13,453 - INFO - Transcript is successfully fetched by api.
2025-07-11 02:44:13,461 - INFO - Chunks has been successfully created.
2025-07-11 02:44:26,321 - INFO - Use pytorch device_name: cpu
2025-07-11 02:44:26,321 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-07-11 02:44:36,220 - INFO - Loading faiss with AVX2 support.
2025-07-11 02:44:36,259 - INFO - Successfully loaded faiss with AVX2 support.
2025-07-11 02:44:36,272 - INFO - Failed to load GPU Faiss: name 'GpuIndexIVFFlat' is not defined. Will not load constructor refs for GPU indexes. This is only an error if you're trying to use GPU Faiss.
2025-07-11 02:44:36,275 - INFO - chunks has been successfully stored in vector database.
2025-07-11 02:44:36,275 - INFO - {0: '78f480e9-ada0-4831-9032-2d2f09a9f4c2', 1: '65330d66-657a-4c90-be62-b65e1b1816dd', 2: '3ddc1a46-94c6-4867-8564-aa9398290869', 3: '0a246182-c012-4083-911c-63c22c8a1e52', 4: '9aac926e-b5d7-4f3c-8229-00767620fe20', 5: 'f872db23-6175-46b0-8bec-fef385ec1d8e', 6: '3b98b47e-fc1c-43a3-aaa2-9ddb6526c280', 7: 'f06e4ce4-6d3e-42fa-b769-a935231ecdda', 8: 'f3f1d5f3-b64a-4eea-82d1-d850df73788e', 9: '4a50bd9e-6a65-46c2-8508-5037c1ef9801', 10: 'd185e4ee-7b30-4f22-a690-169adae3129b', 11: '6ab65b8d-fd76-49c1-8ccd-669208258b09', 12: '0d87ec7d-3c26-4e53-9279-0596d0b9c2d0', 13: 'd081196a-aee6-4296-a968-288e42ed9e6c', 14: 'd98334d0-a677-45e8-951b-3451d011bfc8', 15: '6080b74f-f67f-4fe4-b441-aa6a0edb3551', 16: 'c4f31600-1ef2-42b4-9d85-c4d7c5a02a14', 17: 'baf7baed-e5b9-4409-8267-05ce552454ba', 18: '6dde1a6d-02b1-41bd-bab5-94836128abd2', 19: 'e38aa676-c254-4263-97ae-e6a9faec195a', 20: '6032371b-02ba-4752-83d5-6722ad7fb65b', 21: '75a73d7e-a50a-4050-9aa9-ce767ee72042', 22: 'f089de4e-afe6-4b31-abb5-9fb1a27b085d', 23: 'da5ca4ea-fc26-49b1-85a7-149cea17457f', 24: '0439adf7-b434-4e06-a413-3759ce81a5e4', 25: '7adea957-9488-43c5-be5c-12706ca561a8', 26: '13ec81d3-5147-42ee-940c-a5440b167e19', 27: 'dc37a0dc-46bd-4d30-be4c-5298ca435845', 28: 'f3b49268-0b60-4f4f-8577-69d488f0b578', 29: 'cb975d36-eb14-4bd3-9235-53cf1e775e24', 30: 'bc8782af-4b0d-4062-b622-175a85c2392b', 31: '0ef8d384-e532-4e45-98a4-79ceb7a78c58', 32: '79307bd6-e522-4a17-af01-d8439a4a0239', 33: 'de8df484-b607-441b-a762-e6b78571b158', 34: '85171168-a92f-4b87-a34e-2d28d58c96ed', 35: '2cba13a7-c000-4dc7-8953-13c390eec773', 36: '2ca3cb17-e10d-43f7-a852-7937c1d9a2fc', 37: '67509cf7-5e5c-4bb8-a6cd-43fdbb87051e', 38: '3163ec04-8fb8-4fe4-9f31-a9ed1e5957f5', 39: '937730ec-fd6e-462c-bc9b-2c78e60ccea7', 40: 'afb50a07-2479-45a0-84a5-9160c139d683', 41: '6f51b71f-b77c-40a9-9ea3-d40dbf942b13', 42: 'f01e1031-76d1-4c31-8906-def93d25a787', 43: '46ed6e98-a0c6-487c-b9ed-e76a60677f45', 44: '81047fd4-db7b-4852-be6f-72ea6efec109', 45: '3a2bcbc3-88fa-44cf-ba2d-42232b98a995'}
2025-07-11 02:44:36,275 - INFO - length of chunks: 46
2025-07-11 02:44:36,277 - INFO - Retriever is working good.
2025-07-11 02:44:36,277 - INFO - 
 
 Token is: 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 
 

2025-07-11 02:44:43,678 - INFO - Transcript : hey guys Greg here let's talk about linked lists today and there's two types of them there's singly linked lists as well as doubly linked lists now in picture form a singly linked list might look something like this which is basically circles with values in them and then they point to other circles with the values so we have one pointing to two which points to three and the three actually points over to nothing and that's important because that kind of signifies here that this is the end of the list okay so we'd call this a singly linked list basically because there's this single connection here between the nodes later on we'll see a doubly link list that would basically just be this where we have the backwards link as well but this is called a singly linked list where basically each of these things generally you call them a linked list node or in short form you generally just call them a node so a node is like an object and it has a couple different features to it one it has some sort of memory address as to where it's located in the computer so this is not like an array where an array is like a contiguous sequence of computer memory this is not the case here we actually have this as some sort of address which is going to be some hex code it doesn't really matter what this is here just know that it's some memory address and I'll just kind of short form this to be a so it's the memory address of a and this one would have a completely different memory address likely even very far away in the computer memory of B and this one might be called C and this last thing here what it's pointing over to is generally in a programming language something like null so you might see it be called null in Python we generally have that called none whatever it is it's just some programming language specific that says a special marker saying this is the end of the list okay so what actually is a linked list node well in a computer programming language we have these things called classes okay and classes create these things called objects so basically you would have some sort of thing called like a class node object it would have a value as you can see here it clearly has a node. value we'll write it like that and it also has a node. next so node. next is basically a reference to a different object if we were talking about this guy here well then it would have a next of basically the address of B saying that its next address is pointing over to B and what that allows us to do if you have a its next is pointing over to B and its next is C and its next is none well then this forms a chain because we can basically start here generally you would have some sort of a reference to the head of the linked list which is going to be the front of it so given this reference to the head here well then we can basically go through the list here until we hit none now this is basically an alternative way to store data compared to say an array where an array has certain elements like if you were to ask what is the array at maybe an index of five well in O of one time that array would tell you what is at position five but that's not a thing for a linked list here you can't say what is at the index these things don't have indices generally what we're given is the head to the linked list and to find any of the different elements in here you'd actually have to Traverse the list to do that now by the way here we're storing just the values of 1 2 and three but you can pretty much store any type of data you want in one of those linked list nodes but for lead code style problems they generally just kind of have the numbers there okay so there's a few different things you might want to do with a linked list for example if you wanted to add a new node at an arbitrary positions so maybe add a node at the position of two for example well we don't really have positions here like an array but you could still think of it as this is say the first spot this is the second spot and the third spot and we'll say that we're adding the Noe of a value of five you'd have to start at your head because that's generally all that you're given you're not actually generally given a b and c here and so to add the node at position two you would have to Traverse the list from the start until you got to that position and then you could put that Noe in there you would want one to point over to the five so you'd have to change one to point that over to five and then you'd have to point the five over to the two a general and O of n operation because you have to start at the head of the linked list Traverse to get to that position and then you can adjust it now similarly if you wanted to instead delete a node at position 2 well then you'd have to start at the beginning pretty much like always and then you'd have to go through until you you get to that position and basically just remove it which would involve pointing the previous one over to the next one like that and then you could think of your positions as adjusted like this so 1 2 and three okay so again that's going to be an oent operation cuz you start at the beginning and go up until that position now even more simply if you wanted to just say access a node at a certain position so you didn't want to remove or add it you just wanted to kind of look what's there well again you'd kind of have to start at the beginning and go up until that position to kind of read that element so again an oent thing to do now an operation we generally perform on pretty much every single data structure that we have is lookup so in this case it would be seeing if a certain value is in the linked list okay so you could probably guess that's going to be an oent operation because in the worst case you would have to go through the entire list and have not found it or if you were looking up say something like two well then you would go through and see that two is there but still that's going to be an O of n thing to do now there is a couple things that are o of One op operations so one thing that linked lists are really good at is if you are talking about the beginning of the list so if you wanted to basically remove the thing at the beginning well then that is going to be an O of one operation because basically you would just kind of Point your head element over to this second position here so that would effectively just remove this and then you could think of your positions as one and two although I'm going to stop kind of writing the positions because they don't really exist if you wanted to add a new head so if all you wanted to do is kind of put some something at the very beginning well then yeah that's also going to be o of one you'd basically Point your head over to that new element and then you would Point your new element over to that one so that's also going to be o of one and if you particularly happen to have the reference to say the node here so maybe you happen to have node C over here and you wanted to say remove that what's kind of tricky about this is that if you just kind of remove this given access to node C well then how do you actually change where this node points to because it's sing linked list and so just given C you don't actually have the ability to adjust this one here you want to adjust this next pointer except you don't have that because you just have this node so that's why in practice a lot of the time we actually switch over to doubly link lists which is basically going to be the exact same thing here except we have the reverse connection and our head would actually Point reverse Direction over to none as well so basically saying we have a head element so we still have a head which I'm just going to Mark as h and we also kind of have access immediately to this tail so generally now instead of just access to the front you also have access to the back via the tail and we can kind of go both directions here you could Traverse through this way or you could Traverse backwards so this is a doubly linked list and by the way how this might look in a programming language is you might have a class node which is basically going to have three things now it would have basically a node do value so what it's storing it would have a no. next these are the exact same things as before but then you also might have a node. previous basically saying that each node here they all have a next pointer and they also have a previous pointer and sometimes I might say pointer sometimes I might say reference if you really truly want to understand the whole pointer thing then you'd want to take a class in C but from a python perspective it's basically just that node. nextext is like a reference to a node object and node. preve would be a reference to a node object as well now one thing the W link list does help with is if you had say a reference to this node here you had that if you wanted to delete that so basically if you wanted to delete node B well then you actually only need access to this node here because from this node you could actually access this one because you have the connection to it and you could also access this one so you could actually remove it because basically what you'd have to do is point this previous thing over to the next one and you'd have to point its next one basically back over to the previous one so this does allow basically deleting an element at a particular reference that would actually be constant although we often don't have that ability because generally you only have access to the head and the tail sometimes you have access to kind of the middle node references okay so let's see how we can work with singly and doubly linked lists in Python okay let's start with singly linked lists here so we need a class that makes a node we'll call it singly node and so for the Constructor here now they're going to take a value and they're going to take a next pointer so what it's pointing over to and by default this is just none or null okay and all the Constructor is going to do is just set that its value is the value passed in and the next pointer is the next passed in okay then we'll just give it a simple print method so we can print one of these that is the string method so underscore string like that and this just returns some sort of a string representation so this is going to be the string of the self. Val so we take whatever the V is we just convert that to a string and that's how this thing is going to print okay then to make a linked list you generally have reference only to the head so we'll call it head that's going to be a singly node which just has a value of one now by default this will make the next pointer just none but we'll set those explicitly in a moment we'll get three other nodes I'll call it a is the singly node of three and B is the singly node of four and C is the singly node of seven so we now have four different nodes where the head is one okay now to actually join these things up here by default we kind of just have these floating around in space we want to connect them up so head. next is equal to a points head over to a then a do next is equal to B and b. nextt is equal to C so now we have the connection of head points over to a which points over to B which points over to C and then C is still pointing over to nothing and for now we can just print the head of the list although that's not going to show the full list it's just going to show the value of the first node okay now one thing we usually want to do this is the most common pattern with length lists is some sort of Travers veral so in general just to Traverse the list print the values to Traverse the list this is going to be of course an O of n operation cuz we're visiting all the nodes then you generally get a variable called something like cerr and we'll point that at the head and we keep moving cerr over so while we have Curr so basically until cerr turns into none we will print the current node and then we are going to just move cerr over so we set cerr equal to c. next this effectively traverses cerr throughout the entire linked list until cerr hits the node of C then it's going to point to c. next which is null it'll end the while loop and so if we're just to run this here we'll see 1 3 47 so most linked list problems will be some sort of pattern where you Traverse the list now something that's going to prove very useful is being able to display it well so just basically displaying the linked list and this is going to take definitely o of n time we're going to call that a function display which takes a head so again we'll get a pointer or variable Curr is equal to the Head we'll build up a list of elements so elements is going to be a dynamic array or a list and then while we have Curr well we have one more element so we'd elements. append add that to the array we'll give it the string of the current Dov value and then we would just move C over so C is equal to c. next now after this Loop concludes we'd eventually have Curr is none and so what we want to do is print the string of the arrow like this and note the spaces so that it looks good do join up the elements so if you haven't seen join before basically what that would do do is given a list of strings so something like this A and B and C well join is going to move them into the string of just ABC but this thing here is what you kind of call a glue it's how it glues them together then when you join them it's going to kind of move them like this so it'll glue them together so it ends up looking like this so that's exactly what this does here if you display so display the original head that's going to show the link list very pretty like that okay now something you might want to do is search for a node so search sech for a node value and that's going to take o of n time so to do that we'll Define a function called search which again takes a head and it's also going to take a value to look for this pattern comes up all the time C is equal to head and then while we have C if the Val we're looking for is equal to the current value well then that means we found it and so we would return true if that wasn't the case then we need to keep looking so we set Cur equal to c. next and if this Loop ever concludes it means that we didn't find it and so we would return false at this level so let's just search for a few things here if we search for the value of two sorry you have to give that the head so search for head and two that is going to show up false we don't have that if you have nine that is also not the case if you have something that is in there like the head of one or the tail of seven clearly our search function works okay there's lots of exciting algorithms to learn about linked lists but you can learn those in the leak code problems okay now we're going to do doubly linked lists so for that again we'd have a class which is called doubly node so we have the forward and backward connection it takes a value that the node is going to be it takes a next pointer by default it's going to be none and it also has a previous which by default is going to be set to none okay then all it's going to do is just set the self. fou equal to the Past in fou and the next is going to be the next and the prieve is going to be the preve and we'll just give it a simple printing function so we'll Define underscore uncore string it's just going to return the string of the self. value the exact same as the previous okay then how we can work with this thing is you need access to both the head and the tail so we'll get head is equal to tail which is equal to a dou node and will give that the value of one if you print the head that should show you that the value is one and if you print the tail they're pointing to the same thing so this is also one so we'll Define a function call it display that takes just the head of the linked list you don't need the tail for this so we'll get Cur is equal to the head our elements is our list and again while we have cerr we want to elements. append the string of the C.V so exactly the same thing and we'd set c equal to c. next and then after we get out of here we just want to print with a different glue so we would print with the double connection like this implying we have forwards and backwards because we do so do join that up with the elements and if we were to run display just on our original head display the head we can see it's just one and that's totally accurate for now we just have one node so we want a function that inserts inserts at the beginning basically meaning getting a new head and that's going to be o of one so we'll Define a function called insert at beginning and that's going to take the head it's also going to take the tail and it's going to take the value that you want the new head to be so you would get a new node which is equal to a doubly node reference so we make a new node if you remember how our class looks here it is the value then next then previous so we want the value to be the value and we want to specifically specify that the next is equal to the head because it's saying that we're making a new node and we want that to be the value that we have we want this to point over to the Head the only thing we'd have to do here is set head. preve so our old head equal to the new node so before the head was basically pointing over to null because it was the head but now we want it to put in the middle pointing it to the new node we just made okay so we would return new node and the tail because this is our new head and the tail stay the same and then you would call this like with head and tail is equal to insert at beginning you'd give it the current head the current Tail as well as a new value and we'll give it the value of three so if we do that and then display our head well this is going to show that we have three at the beginning that made a new head and it points over to the one as the tail now if understanding this function was a little bit tricky that's the whole point of the lead code linked list problems is to get comfortable with drawing and then coding this idea okay similarly we could also do insert at end and I'm just kind of going to copy that and explain that for you we can insert at the end in O of one time where you give the head the tail and a new value you'd make a new node which is going to take that new value and you'd point that new node back over to the tail so that would point it left over to the old tail and then you would just need to update that your old tail is then going to point right over to your new node so this basically makes a new tail and so we'd return the head and the new tail and so if we were to run this with a value of seven we're going to see we have a new tail of seven okay as always you can get this code in the video description deson if you'd like to see it I hope this was helpful guys drop a like if it was and have a great day bye-bye
2025-07-11 02:44:43,679 - INFO - Transcript is successfully fetched by api.
2025-07-11 02:44:43,684 - INFO - Chunks has been successfully created.
2025-07-11 02:44:43,687 - INFO - Use pytorch device_name: cpu
2025-07-11 02:44:43,687 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-07-11 02:44:51,977 - INFO - chunks has been successfully stored in vector database.
2025-07-11 02:44:51,977 - INFO - {0: '9ee88cdc-475f-484d-acfa-e12cdd7fc4ee', 1: '081da189-a5f8-46b6-8fcf-51b397c88574', 2: 'ca53ef03-ef12-4d49-afa3-7b6d39f3d28b', 3: '6c68317f-9d5f-4167-8862-3d3eabca1d7d', 4: '9fd950e6-f4e6-4f7d-88fe-ecea5ffb8624', 5: '31e27f1c-39ae-4804-a639-100e1407f027', 6: '1c4a46be-fb04-4ef0-b319-d3f90e006c20', 7: '9d46aa9a-a68d-4028-918d-bcb94e79c7e8', 8: '5b590888-6241-4723-aa5c-6f8360777872', 9: '2b66b019-eb7d-4ff7-aec6-d810d10322ef', 10: 'ef695b97-46ec-4255-bb91-656ef1123a2c', 11: '37fd9d6a-ca0f-40e3-b793-19b6f42df780', 12: 'bdfed2ed-fadd-4a88-8733-3fb222f8caec', 13: '034028e4-a2c4-4bfa-b97a-ac39a10d3fd1', 14: 'ecf625de-28c7-4de3-b951-dc0f51ae6445', 15: '9e720402-7364-49ff-90e4-f39c7515b7d0', 16: 'f6c2be4e-32fa-4067-ba27-7a69d05ac1d3', 17: 'dcb5106a-9fd6-477d-8e95-54f19620a56f', 18: 'de5e52c4-3740-48f0-919e-5d90636a11f7', 19: 'cbafea98-a43f-4e0e-99b0-f1360083bb33', 20: 'd89cbdd5-2afb-44da-bb79-4a1008c27559', 21: '64e43f3c-3181-499f-9c4a-c8404db713ae', 22: 'abec53fe-34cc-405d-b937-e50af8c5795b', 23: 'd314c0b3-de91-4d32-bac6-3b05c6d42fea', 24: 'b55f915e-35f7-4dad-970b-5181aabbead4', 25: 'c6086d26-1e86-43ec-a5bc-2b11b8c3b8ac', 26: '7eefe5c4-8934-41c7-8860-8972ed2c5c7f', 27: '9edacdc9-0040-4073-9dce-200a1eb12db9', 28: '00ad5842-bfb4-409c-a8e6-370001cbe635', 29: '8a2bd7a6-56e4-4dc6-b9e3-465907e65649', 30: 'bac5a105-9f77-4572-b082-a6e33a2a5497', 31: 'f25ab4d1-578e-4dd4-ba68-8f0d5b8f627b', 32: '49ad265f-0df9-4d1a-bbe1-1f30f35d2b63', 33: 'd77b7cbb-965b-4192-bdd0-8026e37c8d8c', 34: 'fe26c752-2f36-495f-bb18-78d8c2401ec9', 35: '7f5d0fbf-ed95-4bff-91cb-c3437a3265b6', 36: '79f63ab0-0043-49f1-b55f-34999a9c71b9', 37: 'cef83d4d-eff9-4663-bc68-7317cab2f328', 38: '7cabe9f7-40e8-42a4-b93b-b9faa2983380', 39: '65489145-2dad-49fc-beb1-eedcb13744b0', 40: 'a5a1c9bb-d16f-4efc-8c31-a771e4ae98de', 41: 'f382de37-e117-4ade-9beb-f89aad2d0c4a', 42: '67e1d62e-8544-4016-a698-5d10c4a8101e', 43: '68f0917e-3b77-40a2-b37a-67e6de71faf4', 44: '24b1fcda-691b-46a0-bacc-113eafbebbe8', 45: '92feda21-9d85-46e4-8e90-eae77f102328'}
2025-07-11 02:44:51,977 - INFO - length of chunks: 46
2025-07-11 02:44:51,978 - INFO - Retriever is working good.
2025-07-11 02:44:51,978 - INFO - 
 
 Token is: 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 
 

2025-07-11 02:44:59,769 - INFO - Transcript : hey guys Greg here let's talk about linked lists today and there's two types of them there's singly linked lists as well as doubly linked lists now in picture form a singly linked list might look something like this which is basically circles with values in them and then they point to other circles with the values so we have one pointing to two which points to three and the three actually points over to nothing and that's important because that kind of signifies here that this is the end of the list okay so we'd call this a singly linked list basically because there's this single connection here between the nodes later on we'll see a doubly link list that would basically just be this where we have the backwards link as well but this is called a singly linked list where basically each of these things generally you call them a linked list node or in short form you generally just call them a node so a node is like an object and it has a couple different features to it one it has some sort of memory address as to where it's located in the computer so this is not like an array where an array is like a contiguous sequence of computer memory this is not the case here we actually have this as some sort of address which is going to be some hex code it doesn't really matter what this is here just know that it's some memory address and I'll just kind of short form this to be a so it's the memory address of a and this one would have a completely different memory address likely even very far away in the computer memory of B and this one might be called C and this last thing here what it's pointing over to is generally in a programming language something like null so you might see it be called null in Python we generally have that called none whatever it is it's just some programming language specific that says a special marker saying this is the end of the list okay so what actually is a linked list node well in a computer programming language we have these things called classes okay and classes create these things called objects so basically you would have some sort of thing called like a class node object it would have a value as you can see here it clearly has a node. value we'll write it like that and it also has a node. next so node. next is basically a reference to a different object if we were talking about this guy here well then it would have a next of basically the address of B saying that its next address is pointing over to B and what that allows us to do if you have a its next is pointing over to B and its next is C and its next is none well then this forms a chain because we can basically start here generally you would have some sort of a reference to the head of the linked list which is going to be the front of it so given this reference to the head here well then we can basically go through the list here until we hit none now this is basically an alternative way to store data compared to say an array where an array has certain elements like if you were to ask what is the array at maybe an index of five well in O of one time that array would tell you what is at position five but that's not a thing for a linked list here you can't say what is at the index these things don't have indices generally what we're given is the head to the linked list and to find any of the different elements in here you'd actually have to Traverse the list to do that now by the way here we're storing just the values of 1 2 and three but you can pretty much store any type of data you want in one of those linked list nodes but for lead code style problems they generally just kind of have the numbers there okay so there's a few different things you might want to do with a linked list for example if you wanted to add a new node at an arbitrary positions so maybe add a node at the position of two for example well we don't really have positions here like an array but you could still think of it as this is say the first spot this is the second spot and the third spot and we'll say that we're adding the Noe of a value of five you'd have to start at your head because that's generally all that you're given you're not actually generally given a b and c here and so to add the node at position two you would have to Traverse the list from the start until you got to that position and then you could put that Noe in there you would want one to point over to the five so you'd have to change one to point that over to five and then you'd have to point the five over to the two a general and O of n operation because you have to start at the head of the linked list Traverse to get to that position and then you can adjust it now similarly if you wanted to instead delete a node at position 2 well then you'd have to start at the beginning pretty much like always and then you'd have to go through until you you get to that position and basically just remove it which would involve pointing the previous one over to the next one like that and then you could think of your positions as adjusted like this so 1 2 and three okay so again that's going to be an oent operation cuz you start at the beginning and go up until that position now even more simply if you wanted to just say access a node at a certain position so you didn't want to remove or add it you just wanted to kind of look what's there well again you'd kind of have to start at the beginning and go up until that position to kind of read that element so again an oent thing to do now an operation we generally perform on pretty much every single data structure that we have is lookup so in this case it would be seeing if a certain value is in the linked list okay so you could probably guess that's going to be an oent operation because in the worst case you would have to go through the entire list and have not found it or if you were looking up say something like two well then you would go through and see that two is there but still that's going to be an O of n thing to do now there is a couple things that are o of One op operations so one thing that linked lists are really good at is if you are talking about the beginning of the list so if you wanted to basically remove the thing at the beginning well then that is going to be an O of one operation because basically you would just kind of Point your head element over to this second position here so that would effectively just remove this and then you could think of your positions as one and two although I'm going to stop kind of writing the positions because they don't really exist if you wanted to add a new head so if all you wanted to do is kind of put some something at the very beginning well then yeah that's also going to be o of one you'd basically Point your head over to that new element and then you would Point your new element over to that one so that's also going to be o of one and if you particularly happen to have the reference to say the node here so maybe you happen to have node C over here and you wanted to say remove that what's kind of tricky about this is that if you just kind of remove this given access to node C well then how do you actually change where this node points to because it's sing linked list and so just given C you don't actually have the ability to adjust this one here you want to adjust this next pointer except you don't have that because you just have this node so that's why in practice a lot of the time we actually switch over to doubly link lists which is basically going to be the exact same thing here except we have the reverse connection and our head would actually Point reverse Direction over to none as well so basically saying we have a head element so we still have a head which I'm just going to Mark as h and we also kind of have access immediately to this tail so generally now instead of just access to the front you also have access to the back via the tail and we can kind of go both directions here you could Traverse through this way or you could Traverse backwards so this is a doubly linked list and by the way how this might look in a programming language is you might have a class node which is basically going to have three things now it would have basically a node do value so what it's storing it would have a no. next these are the exact same things as before but then you also might have a node. previous basically saying that each node here they all have a next pointer and they also have a previous pointer and sometimes I might say pointer sometimes I might say reference if you really truly want to understand the whole pointer thing then you'd want to take a class in C but from a python perspective it's basically just that node. nextext is like a reference to a node object and node. preve would be a reference to a node object as well now one thing the W link list does help with is if you had say a reference to this node here you had that if you wanted to delete that so basically if you wanted to delete node B well then you actually only need access to this node here because from this node you could actually access this one because you have the connection to it and you could also access this one so you could actually remove it because basically what you'd have to do is point this previous thing over to the next one and you'd have to point its next one basically back over to the previous one so this does allow basically deleting an element at a particular reference that would actually be constant although we often don't have that ability because generally you only have access to the head and the tail sometimes you have access to kind of the middle node references okay so let's see how we can work with singly and doubly linked lists in Python okay let's start with singly linked lists here so we need a class that makes a node we'll call it singly node and so for the Constructor here now they're going to take a value and they're going to take a next pointer so what it's pointing over to and by default this is just none or null okay and all the Constructor is going to do is just set that its value is the value passed in and the next pointer is the next passed in okay then we'll just give it a simple print method so we can print one of these that is the string method so underscore string like that and this just returns some sort of a string representation so this is going to be the string of the self. Val so we take whatever the V is we just convert that to a string and that's how this thing is going to print okay then to make a linked list you generally have reference only to the head so we'll call it head that's going to be a singly node which just has a value of one now by default this will make the next pointer just none but we'll set those explicitly in a moment we'll get three other nodes I'll call it a is the singly node of three and B is the singly node of four and C is the singly node of seven so we now have four different nodes where the head is one okay now to actually join these things up here by default we kind of just have these floating around in space we want to connect them up so head. next is equal to a points head over to a then a do next is equal to B and b. nextt is equal to C so now we have the connection of head points over to a which points over to B which points over to C and then C is still pointing over to nothing and for now we can just print the head of the list although that's not going to show the full list it's just going to show the value of the first node okay now one thing we usually want to do this is the most common pattern with length lists is some sort of Travers veral so in general just to Traverse the list print the values to Traverse the list this is going to be of course an O of n operation cuz we're visiting all the nodes then you generally get a variable called something like cerr and we'll point that at the head and we keep moving cerr over so while we have Curr so basically until cerr turns into none we will print the current node and then we are going to just move cerr over so we set cerr equal to c. next this effectively traverses cerr throughout the entire linked list until cerr hits the node of C then it's going to point to c. next which is null it'll end the while loop and so if we're just to run this here we'll see 1 3 47 so most linked list problems will be some sort of pattern where you Traverse the list now something that's going to prove very useful is being able to display it well so just basically displaying the linked list and this is going to take definitely o of n time we're going to call that a function display which takes a head so again we'll get a pointer or variable Curr is equal to the Head we'll build up a list of elements so elements is going to be a dynamic array or a list and then while we have Curr well we have one more element so we'd elements. append add that to the array we'll give it the string of the current Dov value and then we would just move C over so C is equal to c. next now after this Loop concludes we'd eventually have Curr is none and so what we want to do is print the string of the arrow like this and note the spaces so that it looks good do join up the elements so if you haven't seen join before basically what that would do do is given a list of strings so something like this A and B and C well join is going to move them into the string of just ABC but this thing here is what you kind of call a glue it's how it glues them together then when you join them it's going to kind of move them like this so it'll glue them together so it ends up looking like this so that's exactly what this does here if you display so display the original head that's going to show the link list very pretty like that okay now something you might want to do is search for a node so search sech for a node value and that's going to take o of n time so to do that we'll Define a function called search which again takes a head and it's also going to take a value to look for this pattern comes up all the time C is equal to head and then while we have C if the Val we're looking for is equal to the current value well then that means we found it and so we would return true if that wasn't the case then we need to keep looking so we set Cur equal to c. next and if this Loop ever concludes it means that we didn't find it and so we would return false at this level so let's just search for a few things here if we search for the value of two sorry you have to give that the head so search for head and two that is going to show up false we don't have that if you have nine that is also not the case if you have something that is in there like the head of one or the tail of seven clearly our search function works okay there's lots of exciting algorithms to learn about linked lists but you can learn those in the leak code problems okay now we're going to do doubly linked lists so for that again we'd have a class which is called doubly node so we have the forward and backward connection it takes a value that the node is going to be it takes a next pointer by default it's going to be none and it also has a previous which by default is going to be set to none okay then all it's going to do is just set the self. fou equal to the Past in fou and the next is going to be the next and the prieve is going to be the preve and we'll just give it a simple printing function so we'll Define underscore uncore string it's just going to return the string of the self. value the exact same as the previous okay then how we can work with this thing is you need access to both the head and the tail so we'll get head is equal to tail which is equal to a dou node and will give that the value of one if you print the head that should show you that the value is one and if you print the tail they're pointing to the same thing so this is also one so we'll Define a function call it display that takes just the head of the linked list you don't need the tail for this so we'll get Cur is equal to the head our elements is our list and again while we have cerr we want to elements. append the string of the C.V so exactly the same thing and we'd set c equal to c. next and then after we get out of here we just want to print with a different glue so we would print with the double connection like this implying we have forwards and backwards because we do so do join that up with the elements and if we were to run display just on our original head display the head we can see it's just one and that's totally accurate for now we just have one node so we want a function that inserts inserts at the beginning basically meaning getting a new head and that's going to be o of one so we'll Define a function called insert at beginning and that's going to take the head it's also going to take the tail and it's going to take the value that you want the new head to be so you would get a new node which is equal to a doubly node reference so we make a new node if you remember how our class looks here it is the value then next then previous so we want the value to be the value and we want to specifically specify that the next is equal to the head because it's saying that we're making a new node and we want that to be the value that we have we want this to point over to the Head the only thing we'd have to do here is set head. preve so our old head equal to the new node so before the head was basically pointing over to null because it was the head but now we want it to put in the middle pointing it to the new node we just made okay so we would return new node and the tail because this is our new head and the tail stay the same and then you would call this like with head and tail is equal to insert at beginning you'd give it the current head the current Tail as well as a new value and we'll give it the value of three so if we do that and then display our head well this is going to show that we have three at the beginning that made a new head and it points over to the one as the tail now if understanding this function was a little bit tricky that's the whole point of the lead code linked list problems is to get comfortable with drawing and then coding this idea okay similarly we could also do insert at end and I'm just kind of going to copy that and explain that for you we can insert at the end in O of one time where you give the head the tail and a new value you'd make a new node which is going to take that new value and you'd point that new node back over to the tail so that would point it left over to the old tail and then you would just need to update that your old tail is then going to point right over to your new node so this basically makes a new tail and so we'd return the head and the new tail and so if we were to run this with a value of seven we're going to see we have a new tail of seven okay as always you can get this code in the video description deson if you'd like to see it I hope this was helpful guys drop a like if it was and have a great day bye-bye
2025-07-11 02:44:59,770 - INFO - Transcript is successfully fetched by api.
2025-07-11 02:44:59,776 - INFO - Chunks has been successfully created.
2025-07-11 02:44:59,778 - INFO - Use pytorch device_name: cpu
2025-07-11 02:44:59,778 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-07-11 02:45:08,303 - INFO - chunks has been successfully stored in vector database.
2025-07-11 02:45:08,303 - INFO - {0: 'f292210f-1d38-4ccf-9e25-6490e9f18d5d', 1: '8f8c2ee3-92ef-43f4-8b1c-3b8d395394d0', 2: '263a7e3b-97f0-4d8a-b240-27e331023539', 3: '0cd0fd0e-00f9-48b7-af96-7c3c61de0b83', 4: '93997eff-cc5b-4e41-850b-f739d0aed8f0', 5: 'c4dae06c-778a-4a85-8720-77f6ae7ff866', 6: '989ef46b-f0d6-4276-96e6-2546982309e5', 7: 'a086dcbc-058e-4a31-9eea-34d970bdb163', 8: '7fd70add-cddb-4c2a-9c80-527dc13734be', 9: '0e9dd887-9b41-4bb1-b790-8444226fb7ea', 10: 'a779f942-5b9c-4219-8f50-e0422e2d4c98', 11: '5f087db0-c528-4347-bbe3-abea7c70b4e4', 12: '2439bfe3-fc89-4290-b91d-a4cfadabac55', 13: 'd9cdeb93-3657-427b-a41d-86f4ad1cfa0c', 14: 'ba7473a5-20ec-4a81-83ec-eaddbc9593f9', 15: 'a9791b04-9e22-4747-9922-e0cf99d590d4', 16: '5519ee4a-1fd1-481a-887a-2a796ee8f3da', 17: 'f5945f4b-a33f-4a55-8848-a5aa9ebf2b93', 18: 'e8809c85-6262-4d49-9de1-7849f568abac', 19: 'e7614d25-ea8d-4d12-90b0-17b6f0d64cd8', 20: '2869af7d-0038-4a75-bad4-391be4f61c52', 21: '944cdb3b-716e-41e6-a365-0bed72d69045', 22: '8503d80c-d543-4ff4-b052-559f81baaca3', 23: 'dedbeb25-a190-4207-957e-136daad653fd', 24: '4e5c7bbc-42be-4604-95f4-a49518f3aef4', 25: '65aad04e-34a5-451f-b695-43a70d932355', 26: '2a4a34a5-82f2-4353-9af6-ad0be94414c6', 27: '5ceb83db-398e-45c4-b27a-848f99681904', 28: '7b853156-2d25-4858-b8a4-830b35442c94', 29: '45e6dd99-950b-4705-b76a-0af25beeb82d', 30: '89d638fc-7737-4cd9-aeb6-ba7806ea95f7', 31: '4e6bfef7-6fdb-49b8-9a85-0e7e46425b83', 32: '5511606b-f623-4cc2-985a-a25e0dc2f5a6', 33: '1cf2a738-abab-49dd-982f-57ed623a80cd', 34: '38de5b2a-4fed-4693-8216-ce02ebbc1cf9', 35: '0c660252-455b-40cb-80bd-fa9672c995d9', 36: 'beea53e4-bd65-4223-91c7-b65e2b9a0f0f', 37: '6bada729-bb08-443e-bd72-865a2dcecab8', 38: 'aab9afa9-341a-42cb-8869-c5379b92f1fe', 39: '88c2d3a4-2baf-4b92-81cb-55ee85fe0373', 40: '141e6f43-7f03-4887-bc37-46050d9a0534', 41: 'e6749712-624f-43a4-8430-ec406389e3c7', 42: '9bea1950-d06f-4b95-93c1-43a0ae92cecf', 43: '123ff68c-515a-45c0-bf2d-4ead4d9abe68', 44: 'f07a8ea3-21a5-4a17-b90b-aeac262b7ba8', 45: '14c26117-0f9b-4d9f-b1d6-8da8682457dc'}
2025-07-11 02:45:08,303 - INFO - length of chunks: 46
2025-07-11 02:45:08,304 - INFO - Retriever is working good.
2025-07-11 02:45:08,305 - INFO - 
 
 Token is: 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 
 

2025-07-11 02:58:27,899 - INFO - Transcript : hey guys Greg here let's talk about linked lists today and there's two types of them there's singly linked lists as well as doubly linked lists now in picture form a singly linked list might look something like this which is basically circles with values in them and then they point to other circles with the values so we have one pointing to two which points to three and the three actually points over to nothing and that's important because that kind of signifies here that this is the end of the list okay so we'd call this a singly linked list basically because there's this single connection here between the nodes later on we'll see a doubly link list that would basically just be this where we have the backwards link as well but this is called a singly linked list where basically each of these things generally you call them a linked list node or in short form you generally just call them a node so a node is like an object and it has a couple different features to it one it has some sort of memory address as to where it's located in the computer so this is not like an array where an array is like a contiguous sequence of computer memory this is not the case here we actually have this as some sort of address which is going to be some hex code it doesn't really matter what this is here just know that it's some memory address and I'll just kind of short form this to be a so it's the memory address of a and this one would have a completely different memory address likely even very far away in the computer memory of B and this one might be called C and this last thing here what it's pointing over to is generally in a programming language something like null so you might see it be called null in Python we generally have that called none whatever it is it's just some programming language specific that says a special marker saying this is the end of the list okay so what actually is a linked list node well in a computer programming language we have these things called classes okay and classes create these things called objects so basically you would have some sort of thing called like a class node object it would have a value as you can see here it clearly has a node. value we'll write it like that and it also has a node. next so node. next is basically a reference to a different object if we were talking about this guy here well then it would have a next of basically the address of B saying that its next address is pointing over to B and what that allows us to do if you have a its next is pointing over to B and its next is C and its next is none well then this forms a chain because we can basically start here generally you would have some sort of a reference to the head of the linked list which is going to be the front of it so given this reference to the head here well then we can basically go through the list here until we hit none now this is basically an alternative way to store data compared to say an array where an array has certain elements like if you were to ask what is the array at maybe an index of five well in O of one time that array would tell you what is at position five but that's not a thing for a linked list here you can't say what is at the index these things don't have indices generally what we're given is the head to the linked list and to find any of the different elements in here you'd actually have to Traverse the list to do that now by the way here we're storing just the values of 1 2 and three but you can pretty much store any type of data you want in one of those linked list nodes but for lead code style problems they generally just kind of have the numbers there okay so there's a few different things you might want to do with a linked list for example if you wanted to add a new node at an arbitrary positions so maybe add a node at the position of two for example well we don't really have positions here like an array but you could still think of it as this is say the first spot this is the second spot and the third spot and we'll say that we're adding the Noe of a value of five you'd have to start at your head because that's generally all that you're given you're not actually generally given a b and c here and so to add the node at position two you would have to Traverse the list from the start until you got to that position and then you could put that Noe in there you would want one to point over to the five so you'd have to change one to point that over to five and then you'd have to point the five over to the two a general and O of n operation because you have to start at the head of the linked list Traverse to get to that position and then you can adjust it now similarly if you wanted to instead delete a node at position 2 well then you'd have to start at the beginning pretty much like always and then you'd have to go through until you you get to that position and basically just remove it which would involve pointing the previous one over to the next one like that and then you could think of your positions as adjusted like this so 1 2 and three okay so again that's going to be an oent operation cuz you start at the beginning and go up until that position now even more simply if you wanted to just say access a node at a certain position so you didn't want to remove or add it you just wanted to kind of look what's there well again you'd kind of have to start at the beginning and go up until that position to kind of read that element so again an oent thing to do now an operation we generally perform on pretty much every single data structure that we have is lookup so in this case it would be seeing if a certain value is in the linked list okay so you could probably guess that's going to be an oent operation because in the worst case you would have to go through the entire list and have not found it or if you were looking up say something like two well then you would go through and see that two is there but still that's going to be an O of n thing to do now there is a couple things that are o of One op operations so one thing that linked lists are really good at is if you are talking about the beginning of the list so if you wanted to basically remove the thing at the beginning well then that is going to be an O of one operation because basically you would just kind of Point your head element over to this second position here so that would effectively just remove this and then you could think of your positions as one and two although I'm going to stop kind of writing the positions because they don't really exist if you wanted to add a new head so if all you wanted to do is kind of put some something at the very beginning well then yeah that's also going to be o of one you'd basically Point your head over to that new element and then you would Point your new element over to that one so that's also going to be o of one and if you particularly happen to have the reference to say the node here so maybe you happen to have node C over here and you wanted to say remove that what's kind of tricky about this is that if you just kind of remove this given access to node C well then how do you actually change where this node points to because it's sing linked list and so just given C you don't actually have the ability to adjust this one here you want to adjust this next pointer except you don't have that because you just have this node so that's why in practice a lot of the time we actually switch over to doubly link lists which is basically going to be the exact same thing here except we have the reverse connection and our head would actually Point reverse Direction over to none as well so basically saying we have a head element so we still have a head which I'm just going to Mark as h and we also kind of have access immediately to this tail so generally now instead of just access to the front you also have access to the back via the tail and we can kind of go both directions here you could Traverse through this way or you could Traverse backwards so this is a doubly linked list and by the way how this might look in a programming language is you might have a class node which is basically going to have three things now it would have basically a node do value so what it's storing it would have a no. next these are the exact same things as before but then you also might have a node. previous basically saying that each node here they all have a next pointer and they also have a previous pointer and sometimes I might say pointer sometimes I might say reference if you really truly want to understand the whole pointer thing then you'd want to take a class in C but from a python perspective it's basically just that node. nextext is like a reference to a node object and node. preve would be a reference to a node object as well now one thing the W link list does help with is if you had say a reference to this node here you had that if you wanted to delete that so basically if you wanted to delete node B well then you actually only need access to this node here because from this node you could actually access this one because you have the connection to it and you could also access this one so you could actually remove it because basically what you'd have to do is point this previous thing over to the next one and you'd have to point its next one basically back over to the previous one so this does allow basically deleting an element at a particular reference that would actually be constant although we often don't have that ability because generally you only have access to the head and the tail sometimes you have access to kind of the middle node references okay so let's see how we can work with singly and doubly linked lists in Python okay let's start with singly linked lists here so we need a class that makes a node we'll call it singly node and so for the Constructor here now they're going to take a value and they're going to take a next pointer so what it's pointing over to and by default this is just none or null okay and all the Constructor is going to do is just set that its value is the value passed in and the next pointer is the next passed in okay then we'll just give it a simple print method so we can print one of these that is the string method so underscore string like that and this just returns some sort of a string representation so this is going to be the string of the self. Val so we take whatever the V is we just convert that to a string and that's how this thing is going to print okay then to make a linked list you generally have reference only to the head so we'll call it head that's going to be a singly node which just has a value of one now by default this will make the next pointer just none but we'll set those explicitly in a moment we'll get three other nodes I'll call it a is the singly node of three and B is the singly node of four and C is the singly node of seven so we now have four different nodes where the head is one okay now to actually join these things up here by default we kind of just have these floating around in space we want to connect them up so head. next is equal to a points head over to a then a do next is equal to B and b. nextt is equal to C so now we have the connection of head points over to a which points over to B which points over to C and then C is still pointing over to nothing and for now we can just print the head of the list although that's not going to show the full list it's just going to show the value of the first node okay now one thing we usually want to do this is the most common pattern with length lists is some sort of Travers veral so in general just to Traverse the list print the values to Traverse the list this is going to be of course an O of n operation cuz we're visiting all the nodes then you generally get a variable called something like cerr and we'll point that at the head and we keep moving cerr over so while we have Curr so basically until cerr turns into none we will print the current node and then we are going to just move cerr over so we set cerr equal to c. next this effectively traverses cerr throughout the entire linked list until cerr hits the node of C then it's going to point to c. next which is null it'll end the while loop and so if we're just to run this here we'll see 1 3 47 so most linked list problems will be some sort of pattern where you Traverse the list now something that's going to prove very useful is being able to display it well so just basically displaying the linked list and this is going to take definitely o of n time we're going to call that a function display which takes a head so again we'll get a pointer or variable Curr is equal to the Head we'll build up a list of elements so elements is going to be a dynamic array or a list and then while we have Curr well we have one more element so we'd elements. append add that to the array we'll give it the string of the current Dov value and then we would just move C over so C is equal to c. next now after this Loop concludes we'd eventually have Curr is none and so what we want to do is print the string of the arrow like this and note the spaces so that it looks good do join up the elements so if you haven't seen join before basically what that would do do is given a list of strings so something like this A and B and C well join is going to move them into the string of just ABC but this thing here is what you kind of call a glue it's how it glues them together then when you join them it's going to kind of move them like this so it'll glue them together so it ends up looking like this so that's exactly what this does here if you display so display the original head that's going to show the link list very pretty like that okay now something you might want to do is search for a node so search sech for a node value and that's going to take o of n time so to do that we'll Define a function called search which again takes a head and it's also going to take a value to look for this pattern comes up all the time C is equal to head and then while we have C if the Val we're looking for is equal to the current value well then that means we found it and so we would return true if that wasn't the case then we need to keep looking so we set Cur equal to c. next and if this Loop ever concludes it means that we didn't find it and so we would return false at this level so let's just search for a few things here if we search for the value of two sorry you have to give that the head so search for head and two that is going to show up false we don't have that if you have nine that is also not the case if you have something that is in there like the head of one or the tail of seven clearly our search function works okay there's lots of exciting algorithms to learn about linked lists but you can learn those in the leak code problems okay now we're going to do doubly linked lists so for that again we'd have a class which is called doubly node so we have the forward and backward connection it takes a value that the node is going to be it takes a next pointer by default it's going to be none and it also has a previous which by default is going to be set to none okay then all it's going to do is just set the self. fou equal to the Past in fou and the next is going to be the next and the prieve is going to be the preve and we'll just give it a simple printing function so we'll Define underscore uncore string it's just going to return the string of the self. value the exact same as the previous okay then how we can work with this thing is you need access to both the head and the tail so we'll get head is equal to tail which is equal to a dou node and will give that the value of one if you print the head that should show you that the value is one and if you print the tail they're pointing to the same thing so this is also one so we'll Define a function call it display that takes just the head of the linked list you don't need the tail for this so we'll get Cur is equal to the head our elements is our list and again while we have cerr we want to elements. append the string of the C.V so exactly the same thing and we'd set c equal to c. next and then after we get out of here we just want to print with a different glue so we would print with the double connection like this implying we have forwards and backwards because we do so do join that up with the elements and if we were to run display just on our original head display the head we can see it's just one and that's totally accurate for now we just have one node so we want a function that inserts inserts at the beginning basically meaning getting a new head and that's going to be o of one so we'll Define a function called insert at beginning and that's going to take the head it's also going to take the tail and it's going to take the value that you want the new head to be so you would get a new node which is equal to a doubly node reference so we make a new node if you remember how our class looks here it is the value then next then previous so we want the value to be the value and we want to specifically specify that the next is equal to the head because it's saying that we're making a new node and we want that to be the value that we have we want this to point over to the Head the only thing we'd have to do here is set head. preve so our old head equal to the new node so before the head was basically pointing over to null because it was the head but now we want it to put in the middle pointing it to the new node we just made okay so we would return new node and the tail because this is our new head and the tail stay the same and then you would call this like with head and tail is equal to insert at beginning you'd give it the current head the current Tail as well as a new value and we'll give it the value of three so if we do that and then display our head well this is going to show that we have three at the beginning that made a new head and it points over to the one as the tail now if understanding this function was a little bit tricky that's the whole point of the lead code linked list problems is to get comfortable with drawing and then coding this idea okay similarly we could also do insert at end and I'm just kind of going to copy that and explain that for you we can insert at the end in O of one time where you give the head the tail and a new value you'd make a new node which is going to take that new value and you'd point that new node back over to the tail so that would point it left over to the old tail and then you would just need to update that your old tail is then going to point right over to your new node so this basically makes a new tail and so we'd return the head and the new tail and so if we were to run this with a value of seven we're going to see we have a new tail of seven okay as always you can get this code in the video description deson if you'd like to see it I hope this was helpful guys drop a like if it was and have a great day bye-bye
2025-07-11 02:58:27,900 - INFO - Transcript is successfully fetched by api.
2025-07-11 02:58:27,905 - INFO - Chunks has been successfully created.
2025-07-11 02:58:27,908 - INFO - Use pytorch device_name: cpu
2025-07-11 02:58:27,908 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-07-11 02:58:36,559 - INFO - chunks has been successfully stored in vector database.
2025-07-11 02:58:36,559 - INFO - {0: '7012cdb7-d891-473b-8b7a-d90cd5036316', 1: 'd199ad27-fec3-44f2-84a5-c688883660bf', 2: '873d4bf7-82eb-4ff3-8e15-adf7aab4987b', 3: 'a53bfc96-3665-43ca-b9e8-d4b38b340189', 4: 'a83b86e9-3388-473b-af95-ac9a695400d7', 5: '0d2a0f97-6b66-4def-85e8-992c46203a7f', 6: '4dc436b1-ed13-4c3c-bfce-07b75bcf032e', 7: 'a3f4a817-f932-423e-996e-63f23d34cbfb', 8: '14eb44d5-9221-45f4-bed8-c10348f8305e', 9: '9256f693-6b04-49b4-a60e-d5822e312a7f', 10: 'b2d3fd31-05d5-4b6a-93c5-72e97802d813', 11: '0fccc731-8661-4a71-ba68-5d405fb4be19', 12: '3efe4e78-108c-4a3b-aa22-9aa9c9de5ad4', 13: '252e4656-723c-48d6-bc22-01c2e63641e6', 14: '5e8349f0-c28e-433f-ac53-a489d4a651ca', 15: '8d9a8249-04d4-4aa2-a1eb-88844c74d404', 16: '7e66cf15-e930-4259-882e-71a0fb164744', 17: 'a5e89e30-3a21-4598-ab35-a953e47c7f1f', 18: 'cba79a04-c0e1-428f-a476-771c140b0def', 19: 'e44547cc-fcc5-4f00-8c34-dd04e21fadd9', 20: '2dbdd349-92ab-4390-a288-ea1775c03329', 21: '17b80ed4-4fa9-40f8-ba56-28d26b9aca20', 22: 'c2f42f74-93d1-4ca9-a36f-8dee2a50a55f', 23: '4ba4312f-8598-4eeb-ae00-c5d8e5f204aa', 24: '2a62df28-3ef4-4632-a525-e50f48d18006', 25: '07c328c6-a4c7-433b-b4ca-9be0a96bb6a3', 26: '8e1cc599-34ea-40aa-b612-baba7651e055', 27: 'aa6522a4-2e57-46b0-83bb-f9d0c3a376e5', 28: '725514c9-3fca-4013-a923-368dd06153b4', 29: '5e88b748-2d74-4bdd-a885-b260e8c2dc08', 30: '71031e7c-bf30-4a35-9988-1fca1368560c', 31: 'd112be87-1f93-43f4-9e65-9ec370239697', 32: '45afdce8-d0fb-4a9e-9638-58838791faf7', 33: 'fde13976-e22d-46c9-8d15-1b8e3352fc02', 34: '2a0471e0-7e06-46f0-a862-a3a0526cce86', 35: '974a2851-f03b-4e59-9487-aff5b6e6fdd9', 36: '45646219-ea13-4784-b2de-b227243e28e8', 37: 'd99ace48-00ac-4b88-b47f-596ff0014772', 38: '1989fe72-77df-46be-9d84-013fb561b301', 39: '50292dc0-da20-46b3-b7d3-d2472e56ad72', 40: '570cbe24-9184-4fad-bc16-6e52b7c34379', 41: '0072e67a-a691-4939-8e7d-a25ab37c9108', 42: '5a9e2030-6833-4835-ab78-fbf54f0aabbc', 43: 'a9b7c014-8f62-4d6a-bd6e-fd49d4a95fd1', 44: '4b7ddd6b-db3e-41bb-afef-82d51dfe4235', 45: 'a8ceba80-ae02-4ba8-911d-c637a627bf1c'}
2025-07-11 02:58:36,559 - INFO - length of chunks: 46
2025-07-11 02:58:36,560 - INFO - Retriever is working good.
2025-07-11 02:58:36,560 - INFO - 
 
 Token is: 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 
 

2025-07-11 02:58:42,776 - INFO - Transcript : hey guys Greg here let's talk about linked lists today and there's two types of them there's singly linked lists as well as doubly linked lists now in picture form a singly linked list might look something like this which is basically circles with values in them and then they point to other circles with the values so we have one pointing to two which points to three and the three actually points over to nothing and that's important because that kind of signifies here that this is the end of the list okay so we'd call this a singly linked list basically because there's this single connection here between the nodes later on we'll see a doubly link list that would basically just be this where we have the backwards link as well but this is called a singly linked list where basically each of these things generally you call them a linked list node or in short form you generally just call them a node so a node is like an object and it has a couple different features to it one it has some sort of memory address as to where it's located in the computer so this is not like an array where an array is like a contiguous sequence of computer memory this is not the case here we actually have this as some sort of address which is going to be some hex code it doesn't really matter what this is here just know that it's some memory address and I'll just kind of short form this to be a so it's the memory address of a and this one would have a completely different memory address likely even very far away in the computer memory of B and this one might be called C and this last thing here what it's pointing over to is generally in a programming language something like null so you might see it be called null in Python we generally have that called none whatever it is it's just some programming language specific that says a special marker saying this is the end of the list okay so what actually is a linked list node well in a computer programming language we have these things called classes okay and classes create these things called objects so basically you would have some sort of thing called like a class node object it would have a value as you can see here it clearly has a node. value we'll write it like that and it also has a node. next so node. next is basically a reference to a different object if we were talking about this guy here well then it would have a next of basically the address of B saying that its next address is pointing over to B and what that allows us to do if you have a its next is pointing over to B and its next is C and its next is none well then this forms a chain because we can basically start here generally you would have some sort of a reference to the head of the linked list which is going to be the front of it so given this reference to the head here well then we can basically go through the list here until we hit none now this is basically an alternative way to store data compared to say an array where an array has certain elements like if you were to ask what is the array at maybe an index of five well in O of one time that array would tell you what is at position five but that's not a thing for a linked list here you can't say what is at the index these things don't have indices generally what we're given is the head to the linked list and to find any of the different elements in here you'd actually have to Traverse the list to do that now by the way here we're storing just the values of 1 2 and three but you can pretty much store any type of data you want in one of those linked list nodes but for lead code style problems they generally just kind of have the numbers there okay so there's a few different things you might want to do with a linked list for example if you wanted to add a new node at an arbitrary positions so maybe add a node at the position of two for example well we don't really have positions here like an array but you could still think of it as this is say the first spot this is the second spot and the third spot and we'll say that we're adding the Noe of a value of five you'd have to start at your head because that's generally all that you're given you're not actually generally given a b and c here and so to add the node at position two you would have to Traverse the list from the start until you got to that position and then you could put that Noe in there you would want one to point over to the five so you'd have to change one to point that over to five and then you'd have to point the five over to the two a general and O of n operation because you have to start at the head of the linked list Traverse to get to that position and then you can adjust it now similarly if you wanted to instead delete a node at position 2 well then you'd have to start at the beginning pretty much like always and then you'd have to go through until you you get to that position and basically just remove it which would involve pointing the previous one over to the next one like that and then you could think of your positions as adjusted like this so 1 2 and three okay so again that's going to be an oent operation cuz you start at the beginning and go up until that position now even more simply if you wanted to just say access a node at a certain position so you didn't want to remove or add it you just wanted to kind of look what's there well again you'd kind of have to start at the beginning and go up until that position to kind of read that element so again an oent thing to do now an operation we generally perform on pretty much every single data structure that we have is lookup so in this case it would be seeing if a certain value is in the linked list okay so you could probably guess that's going to be an oent operation because in the worst case you would have to go through the entire list and have not found it or if you were looking up say something like two well then you would go through and see that two is there but still that's going to be an O of n thing to do now there is a couple things that are o of One op operations so one thing that linked lists are really good at is if you are talking about the beginning of the list so if you wanted to basically remove the thing at the beginning well then that is going to be an O of one operation because basically you would just kind of Point your head element over to this second position here so that would effectively just remove this and then you could think of your positions as one and two although I'm going to stop kind of writing the positions because they don't really exist if you wanted to add a new head so if all you wanted to do is kind of put some something at the very beginning well then yeah that's also going to be o of one you'd basically Point your head over to that new element and then you would Point your new element over to that one so that's also going to be o of one and if you particularly happen to have the reference to say the node here so maybe you happen to have node C over here and you wanted to say remove that what's kind of tricky about this is that if you just kind of remove this given access to node C well then how do you actually change where this node points to because it's sing linked list and so just given C you don't actually have the ability to adjust this one here you want to adjust this next pointer except you don't have that because you just have this node so that's why in practice a lot of the time we actually switch over to doubly link lists which is basically going to be the exact same thing here except we have the reverse connection and our head would actually Point reverse Direction over to none as well so basically saying we have a head element so we still have a head which I'm just going to Mark as h and we also kind of have access immediately to this tail so generally now instead of just access to the front you also have access to the back via the tail and we can kind of go both directions here you could Traverse through this way or you could Traverse backwards so this is a doubly linked list and by the way how this might look in a programming language is you might have a class node which is basically going to have three things now it would have basically a node do value so what it's storing it would have a no. next these are the exact same things as before but then you also might have a node. previous basically saying that each node here they all have a next pointer and they also have a previous pointer and sometimes I might say pointer sometimes I might say reference if you really truly want to understand the whole pointer thing then you'd want to take a class in C but from a python perspective it's basically just that node. nextext is like a reference to a node object and node. preve would be a reference to a node object as well now one thing the W link list does help with is if you had say a reference to this node here you had that if you wanted to delete that so basically if you wanted to delete node B well then you actually only need access to this node here because from this node you could actually access this one because you have the connection to it and you could also access this one so you could actually remove it because basically what you'd have to do is point this previous thing over to the next one and you'd have to point its next one basically back over to the previous one so this does allow basically deleting an element at a particular reference that would actually be constant although we often don't have that ability because generally you only have access to the head and the tail sometimes you have access to kind of the middle node references okay so let's see how we can work with singly and doubly linked lists in Python okay let's start with singly linked lists here so we need a class that makes a node we'll call it singly node and so for the Constructor here now they're going to take a value and they're going to take a next pointer so what it's pointing over to and by default this is just none or null okay and all the Constructor is going to do is just set that its value is the value passed in and the next pointer is the next passed in okay then we'll just give it a simple print method so we can print one of these that is the string method so underscore string like that and this just returns some sort of a string representation so this is going to be the string of the self. Val so we take whatever the V is we just convert that to a string and that's how this thing is going to print okay then to make a linked list you generally have reference only to the head so we'll call it head that's going to be a singly node which just has a value of one now by default this will make the next pointer just none but we'll set those explicitly in a moment we'll get three other nodes I'll call it a is the singly node of three and B is the singly node of four and C is the singly node of seven so we now have four different nodes where the head is one okay now to actually join these things up here by default we kind of just have these floating around in space we want to connect them up so head. next is equal to a points head over to a then a do next is equal to B and b. nextt is equal to C so now we have the connection of head points over to a which points over to B which points over to C and then C is still pointing over to nothing and for now we can just print the head of the list although that's not going to show the full list it's just going to show the value of the first node okay now one thing we usually want to do this is the most common pattern with length lists is some sort of Travers veral so in general just to Traverse the list print the values to Traverse the list this is going to be of course an O of n operation cuz we're visiting all the nodes then you generally get a variable called something like cerr and we'll point that at the head and we keep moving cerr over so while we have Curr so basically until cerr turns into none we will print the current node and then we are going to just move cerr over so we set cerr equal to c. next this effectively traverses cerr throughout the entire linked list until cerr hits the node of C then it's going to point to c. next which is null it'll end the while loop and so if we're just to run this here we'll see 1 3 47 so most linked list problems will be some sort of pattern where you Traverse the list now something that's going to prove very useful is being able to display it well so just basically displaying the linked list and this is going to take definitely o of n time we're going to call that a function display which takes a head so again we'll get a pointer or variable Curr is equal to the Head we'll build up a list of elements so elements is going to be a dynamic array or a list and then while we have Curr well we have one more element so we'd elements. append add that to the array we'll give it the string of the current Dov value and then we would just move C over so C is equal to c. next now after this Loop concludes we'd eventually have Curr is none and so what we want to do is print the string of the arrow like this and note the spaces so that it looks good do join up the elements so if you haven't seen join before basically what that would do do is given a list of strings so something like this A and B and C well join is going to move them into the string of just ABC but this thing here is what you kind of call a glue it's how it glues them together then when you join them it's going to kind of move them like this so it'll glue them together so it ends up looking like this so that's exactly what this does here if you display so display the original head that's going to show the link list very pretty like that okay now something you might want to do is search for a node so search sech for a node value and that's going to take o of n time so to do that we'll Define a function called search which again takes a head and it's also going to take a value to look for this pattern comes up all the time C is equal to head and then while we have C if the Val we're looking for is equal to the current value well then that means we found it and so we would return true if that wasn't the case then we need to keep looking so we set Cur equal to c. next and if this Loop ever concludes it means that we didn't find it and so we would return false at this level so let's just search for a few things here if we search for the value of two sorry you have to give that the head so search for head and two that is going to show up false we don't have that if you have nine that is also not the case if you have something that is in there like the head of one or the tail of seven clearly our search function works okay there's lots of exciting algorithms to learn about linked lists but you can learn those in the leak code problems okay now we're going to do doubly linked lists so for that again we'd have a class which is called doubly node so we have the forward and backward connection it takes a value that the node is going to be it takes a next pointer by default it's going to be none and it also has a previous which by default is going to be set to none okay then all it's going to do is just set the self. fou equal to the Past in fou and the next is going to be the next and the prieve is going to be the preve and we'll just give it a simple printing function so we'll Define underscore uncore string it's just going to return the string of the self. value the exact same as the previous okay then how we can work with this thing is you need access to both the head and the tail so we'll get head is equal to tail which is equal to a dou node and will give that the value of one if you print the head that should show you that the value is one and if you print the tail they're pointing to the same thing so this is also one so we'll Define a function call it display that takes just the head of the linked list you don't need the tail for this so we'll get Cur is equal to the head our elements is our list and again while we have cerr we want to elements. append the string of the C.V so exactly the same thing and we'd set c equal to c. next and then after we get out of here we just want to print with a different glue so we would print with the double connection like this implying we have forwards and backwards because we do so do join that up with the elements and if we were to run display just on our original head display the head we can see it's just one and that's totally accurate for now we just have one node so we want a function that inserts inserts at the beginning basically meaning getting a new head and that's going to be o of one so we'll Define a function called insert at beginning and that's going to take the head it's also going to take the tail and it's going to take the value that you want the new head to be so you would get a new node which is equal to a doubly node reference so we make a new node if you remember how our class looks here it is the value then next then previous so we want the value to be the value and we want to specifically specify that the next is equal to the head because it's saying that we're making a new node and we want that to be the value that we have we want this to point over to the Head the only thing we'd have to do here is set head. preve so our old head equal to the new node so before the head was basically pointing over to null because it was the head but now we want it to put in the middle pointing it to the new node we just made okay so we would return new node and the tail because this is our new head and the tail stay the same and then you would call this like with head and tail is equal to insert at beginning you'd give it the current head the current Tail as well as a new value and we'll give it the value of three so if we do that and then display our head well this is going to show that we have three at the beginning that made a new head and it points over to the one as the tail now if understanding this function was a little bit tricky that's the whole point of the lead code linked list problems is to get comfortable with drawing and then coding this idea okay similarly we could also do insert at end and I'm just kind of going to copy that and explain that for you we can insert at the end in O of one time where you give the head the tail and a new value you'd make a new node which is going to take that new value and you'd point that new node back over to the tail so that would point it left over to the old tail and then you would just need to update that your old tail is then going to point right over to your new node so this basically makes a new tail and so we'd return the head and the new tail and so if we were to run this with a value of seven we're going to see we have a new tail of seven okay as always you can get this code in the video description deson if you'd like to see it I hope this was helpful guys drop a like if it was and have a great day bye-bye
2025-07-11 02:58:42,777 - INFO - Transcript is successfully fetched by api.
2025-07-11 02:58:42,784 - INFO - Chunks has been successfully created.
2025-07-11 02:58:42,786 - INFO - Use pytorch device_name: cpu
2025-07-11 02:58:42,786 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-07-11 02:58:51,553 - INFO - chunks has been successfully stored in vector database.
2025-07-11 02:58:51,553 - INFO - {0: 'f05c3dbc-9351-4153-9544-e3ecd75ecc46', 1: 'ade3e228-3e55-4982-9172-37619f405370', 2: '27557343-0c0a-4f14-a767-e573b0362b18', 3: 'c027c858-8b10-4b78-8da9-27d39e05fc9b', 4: 'f5877eb2-feed-4dd8-81e2-a47930fbab3d', 5: '27eb17bf-76a7-4103-85f4-8e9a1d9b93de', 6: '03776b8f-2ebd-4fa4-ac3f-8fbfa85323e9', 7: '84375855-be38-4124-be2c-fe8016a2f3d4', 8: '4008f748-98c0-4688-a6b2-491d2d7d77b0', 9: 'f881efea-c5fe-466d-9314-e6d01e9ad081', 10: 'd20fb6d7-6548-4ad7-b4a4-54126bb720f0', 11: 'bf1a9643-d7ac-428d-9c8e-971b3cd60c19', 12: '8b146744-934d-4b85-bcca-8c823787b6ed', 13: '9ec002d9-93e9-4035-93d0-3bbe08808370', 14: '83b4960a-47ac-4d6a-ab5c-9644815209ed', 15: 'edcb0beb-4e5c-4f63-b6b1-1fd0ad21bfe7', 16: 'e4cdfef0-f9f7-4c5c-a2de-89f95dc39930', 17: '722ed6e2-cdeb-45f3-920f-be8a4c2e2c3f', 18: 'f6efcfc9-5759-439f-ba72-7152e7ed14f4', 19: '2cbce2b0-8b8c-4d89-be6b-ac148e6ab1e0', 20: 'd4332eb3-f1cd-4d5d-9a1b-a0ef79f83bbf', 21: '05e3646b-1917-4733-816f-8a8385a51659', 22: '70a98f01-aa90-4aee-a5b0-53d76896eb6e', 23: '038bc44e-fd8b-4d11-b1a4-3e2edd43f07d', 24: '7233c2c2-310c-4d87-82cf-b78e0214baaa', 25: '11e09766-0176-40ec-89b2-31cf55e92b44', 26: 'e05f01a6-809a-4142-99c2-60816c78bb1f', 27: '44ac49d8-735c-46bc-ac11-1a94d8287e68', 28: '2051518b-400b-4a50-a6c3-8b39cfa29492', 29: '63a703fd-d43c-4d75-b43c-b3b6315abba8', 30: '529d069d-791f-4ab3-ace9-3d77c295835c', 31: '022a885e-952b-44c8-8073-fd7a468ba35d', 32: 'df4f194c-f53c-4b5b-991d-49b33a145748', 33: '138dcb39-96c0-441d-a776-57669c1a9a0b', 34: '7f48a75a-d7d2-455d-8554-a82c96951fb2', 35: 'e4a88755-368b-4a1b-baca-1a700ad3fa6f', 36: '0cbe4c35-4c99-4a7c-b5a0-e7811be86de4', 37: '27cd0021-b502-4d85-86e1-25be33e4dfe2', 38: '66c0a160-7a07-4c7b-872c-f666a52e6add', 39: '0c2edb24-5c64-4c37-b89d-a7271e3e38e3', 40: 'e005d643-4d5e-4e96-9646-c09f0c76b0b6', 41: 'eac28cea-c90d-49cb-991d-1ea258aeaa67', 42: 'b3d3c81a-107b-42cb-ae27-61f418a06a66', 43: '29400323-91b2-48b4-b5e5-89eff3a84a59', 44: 'edf618d2-33bf-49b2-822d-9b10cbbbc082', 45: '39600916-1a83-420c-b329-7327cd6ff064'}
2025-07-11 02:58:51,553 - INFO - length of chunks: 46
2025-07-11 02:58:51,554 - INFO - Retriever is working good.
2025-07-11 02:58:51,555 - INFO - 
 
 Token is: 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 
 

2025-07-11 03:06:04,731 - INFO - Transcript : hey guys Greg here let's talk about linked lists today and there's two types of them there's singly linked lists as well as doubly linked lists now in picture form a singly linked list might look something like this which is basically circles with values in them and then they point to other circles with the values so we have one pointing to two which points to three and the three actually points over to nothing and that's important because that kind of signifies here that this is the end of the list okay so we'd call this a singly linked list basically because there's this single connection here between the nodes later on we'll see a doubly link list that would basically just be this where we have the backwards link as well but this is called a singly linked list where basically each of these things generally you call them a linked list node or in short form you generally just call them a node so a node is like an object and it has a couple different features to it one it has some sort of memory address as to where it's located in the computer so this is not like an array where an array is like a contiguous sequence of computer memory this is not the case here we actually have this as some sort of address which is going to be some hex code it doesn't really matter what this is here just know that it's some memory address and I'll just kind of short form this to be a so it's the memory address of a and this one would have a completely different memory address likely even very far away in the computer memory of B and this one might be called C and this last thing here what it's pointing over to is generally in a programming language something like null so you might see it be called null in Python we generally have that called none whatever it is it's just some programming language specific that says a special marker saying this is the end of the list okay so what actually is a linked list node well in a computer programming language we have these things called classes okay and classes create these things called objects so basically you would have some sort of thing called like a class node object it would have a value as you can see here it clearly has a node. value we'll write it like that and it also has a node. next so node. next is basically a reference to a different object if we were talking about this guy here well then it would have a next of basically the address of B saying that its next address is pointing over to B and what that allows us to do if you have a its next is pointing over to B and its next is C and its next is none well then this forms a chain because we can basically start here generally you would have some sort of a reference to the head of the linked list which is going to be the front of it so given this reference to the head here well then we can basically go through the list here until we hit none now this is basically an alternative way to store data compared to say an array where an array has certain elements like if you were to ask what is the array at maybe an index of five well in O of one time that array would tell you what is at position five but that's not a thing for a linked list here you can't say what is at the index these things don't have indices generally what we're given is the head to the linked list and to find any of the different elements in here you'd actually have to Traverse the list to do that now by the way here we're storing just the values of 1 2 and three but you can pretty much store any type of data you want in one of those linked list nodes but for lead code style problems they generally just kind of have the numbers there okay so there's a few different things you might want to do with a linked list for example if you wanted to add a new node at an arbitrary positions so maybe add a node at the position of two for example well we don't really have positions here like an array but you could still think of it as this is say the first spot this is the second spot and the third spot and we'll say that we're adding the Noe of a value of five you'd have to start at your head because that's generally all that you're given you're not actually generally given a b and c here and so to add the node at position two you would have to Traverse the list from the start until you got to that position and then you could put that Noe in there you would want one to point over to the five so you'd have to change one to point that over to five and then you'd have to point the five over to the two a general and O of n operation because you have to start at the head of the linked list Traverse to get to that position and then you can adjust it now similarly if you wanted to instead delete a node at position 2 well then you'd have to start at the beginning pretty much like always and then you'd have to go through until you you get to that position and basically just remove it which would involve pointing the previous one over to the next one like that and then you could think of your positions as adjusted like this so 1 2 and three okay so again that's going to be an oent operation cuz you start at the beginning and go up until that position now even more simply if you wanted to just say access a node at a certain position so you didn't want to remove or add it you just wanted to kind of look what's there well again you'd kind of have to start at the beginning and go up until that position to kind of read that element so again an oent thing to do now an operation we generally perform on pretty much every single data structure that we have is lookup so in this case it would be seeing if a certain value is in the linked list okay so you could probably guess that's going to be an oent operation because in the worst case you would have to go through the entire list and have not found it or if you were looking up say something like two well then you would go through and see that two is there but still that's going to be an O of n thing to do now there is a couple things that are o of One op operations so one thing that linked lists are really good at is if you are talking about the beginning of the list so if you wanted to basically remove the thing at the beginning well then that is going to be an O of one operation because basically you would just kind of Point your head element over to this second position here so that would effectively just remove this and then you could think of your positions as one and two although I'm going to stop kind of writing the positions because they don't really exist if you wanted to add a new head so if all you wanted to do is kind of put some something at the very beginning well then yeah that's also going to be o of one you'd basically Point your head over to that new element and then you would Point your new element over to that one so that's also going to be o of one and if you particularly happen to have the reference to say the node here so maybe you happen to have node C over here and you wanted to say remove that what's kind of tricky about this is that if you just kind of remove this given access to node C well then how do you actually change where this node points to because it's sing linked list and so just given C you don't actually have the ability to adjust this one here you want to adjust this next pointer except you don't have that because you just have this node so that's why in practice a lot of the time we actually switch over to doubly link lists which is basically going to be the exact same thing here except we have the reverse connection and our head would actually Point reverse Direction over to none as well so basically saying we have a head element so we still have a head which I'm just going to Mark as h and we also kind of have access immediately to this tail so generally now instead of just access to the front you also have access to the back via the tail and we can kind of go both directions here you could Traverse through this way or you could Traverse backwards so this is a doubly linked list and by the way how this might look in a programming language is you might have a class node which is basically going to have three things now it would have basically a node do value so what it's storing it would have a no. next these are the exact same things as before but then you also might have a node. previous basically saying that each node here they all have a next pointer and they also have a previous pointer and sometimes I might say pointer sometimes I might say reference if you really truly want to understand the whole pointer thing then you'd want to take a class in C but from a python perspective it's basically just that node. nextext is like a reference to a node object and node. preve would be a reference to a node object as well now one thing the W link list does help with is if you had say a reference to this node here you had that if you wanted to delete that so basically if you wanted to delete node B well then you actually only need access to this node here because from this node you could actually access this one because you have the connection to it and you could also access this one so you could actually remove it because basically what you'd have to do is point this previous thing over to the next one and you'd have to point its next one basically back over to the previous one so this does allow basically deleting an element at a particular reference that would actually be constant although we often don't have that ability because generally you only have access to the head and the tail sometimes you have access to kind of the middle node references okay so let's see how we can work with singly and doubly linked lists in Python okay let's start with singly linked lists here so we need a class that makes a node we'll call it singly node and so for the Constructor here now they're going to take a value and they're going to take a next pointer so what it's pointing over to and by default this is just none or null okay and all the Constructor is going to do is just set that its value is the value passed in and the next pointer is the next passed in okay then we'll just give it a simple print method so we can print one of these that is the string method so underscore string like that and this just returns some sort of a string representation so this is going to be the string of the self. Val so we take whatever the V is we just convert that to a string and that's how this thing is going to print okay then to make a linked list you generally have reference only to the head so we'll call it head that's going to be a singly node which just has a value of one now by default this will make the next pointer just none but we'll set those explicitly in a moment we'll get three other nodes I'll call it a is the singly node of three and B is the singly node of four and C is the singly node of seven so we now have four different nodes where the head is one okay now to actually join these things up here by default we kind of just have these floating around in space we want to connect them up so head. next is equal to a points head over to a then a do next is equal to B and b. nextt is equal to C so now we have the connection of head points over to a which points over to B which points over to C and then C is still pointing over to nothing and for now we can just print the head of the list although that's not going to show the full list it's just going to show the value of the first node okay now one thing we usually want to do this is the most common pattern with length lists is some sort of Travers veral so in general just to Traverse the list print the values to Traverse the list this is going to be of course an O of n operation cuz we're visiting all the nodes then you generally get a variable called something like cerr and we'll point that at the head and we keep moving cerr over so while we have Curr so basically until cerr turns into none we will print the current node and then we are going to just move cerr over so we set cerr equal to c. next this effectively traverses cerr throughout the entire linked list until cerr hits the node of C then it's going to point to c. next which is null it'll end the while loop and so if we're just to run this here we'll see 1 3 47 so most linked list problems will be some sort of pattern where you Traverse the list now something that's going to prove very useful is being able to display it well so just basically displaying the linked list and this is going to take definitely o of n time we're going to call that a function display which takes a head so again we'll get a pointer or variable Curr is equal to the Head we'll build up a list of elements so elements is going to be a dynamic array or a list and then while we have Curr well we have one more element so we'd elements. append add that to the array we'll give it the string of the current Dov value and then we would just move C over so C is equal to c. next now after this Loop concludes we'd eventually have Curr is none and so what we want to do is print the string of the arrow like this and note the spaces so that it looks good do join up the elements so if you haven't seen join before basically what that would do do is given a list of strings so something like this A and B and C well join is going to move them into the string of just ABC but this thing here is what you kind of call a glue it's how it glues them together then when you join them it's going to kind of move them like this so it'll glue them together so it ends up looking like this so that's exactly what this does here if you display so display the original head that's going to show the link list very pretty like that okay now something you might want to do is search for a node so search sech for a node value and that's going to take o of n time so to do that we'll Define a function called search which again takes a head and it's also going to take a value to look for this pattern comes up all the time C is equal to head and then while we have C if the Val we're looking for is equal to the current value well then that means we found it and so we would return true if that wasn't the case then we need to keep looking so we set Cur equal to c. next and if this Loop ever concludes it means that we didn't find it and so we would return false at this level so let's just search for a few things here if we search for the value of two sorry you have to give that the head so search for head and two that is going to show up false we don't have that if you have nine that is also not the case if you have something that is in there like the head of one or the tail of seven clearly our search function works okay there's lots of exciting algorithms to learn about linked lists but you can learn those in the leak code problems okay now we're going to do doubly linked lists so for that again we'd have a class which is called doubly node so we have the forward and backward connection it takes a value that the node is going to be it takes a next pointer by default it's going to be none and it also has a previous which by default is going to be set to none okay then all it's going to do is just set the self. fou equal to the Past in fou and the next is going to be the next and the prieve is going to be the preve and we'll just give it a simple printing function so we'll Define underscore uncore string it's just going to return the string of the self. value the exact same as the previous okay then how we can work with this thing is you need access to both the head and the tail so we'll get head is equal to tail which is equal to a dou node and will give that the value of one if you print the head that should show you that the value is one and if you print the tail they're pointing to the same thing so this is also one so we'll Define a function call it display that takes just the head of the linked list you don't need the tail for this so we'll get Cur is equal to the head our elements is our list and again while we have cerr we want to elements. append the string of the C.V so exactly the same thing and we'd set c equal to c. next and then after we get out of here we just want to print with a different glue so we would print with the double connection like this implying we have forwards and backwards because we do so do join that up with the elements and if we were to run display just on our original head display the head we can see it's just one and that's totally accurate for now we just have one node so we want a function that inserts inserts at the beginning basically meaning getting a new head and that's going to be o of one so we'll Define a function called insert at beginning and that's going to take the head it's also going to take the tail and it's going to take the value that you want the new head to be so you would get a new node which is equal to a doubly node reference so we make a new node if you remember how our class looks here it is the value then next then previous so we want the value to be the value and we want to specifically specify that the next is equal to the head because it's saying that we're making a new node and we want that to be the value that we have we want this to point over to the Head the only thing we'd have to do here is set head. preve so our old head equal to the new node so before the head was basically pointing over to null because it was the head but now we want it to put in the middle pointing it to the new node we just made okay so we would return new node and the tail because this is our new head and the tail stay the same and then you would call this like with head and tail is equal to insert at beginning you'd give it the current head the current Tail as well as a new value and we'll give it the value of three so if we do that and then display our head well this is going to show that we have three at the beginning that made a new head and it points over to the one as the tail now if understanding this function was a little bit tricky that's the whole point of the lead code linked list problems is to get comfortable with drawing and then coding this idea okay similarly we could also do insert at end and I'm just kind of going to copy that and explain that for you we can insert at the end in O of one time where you give the head the tail and a new value you'd make a new node which is going to take that new value and you'd point that new node back over to the tail so that would point it left over to the old tail and then you would just need to update that your old tail is then going to point right over to your new node so this basically makes a new tail and so we'd return the head and the new tail and so if we were to run this with a value of seven we're going to see we have a new tail of seven okay as always you can get this code in the video description deson if you'd like to see it I hope this was helpful guys drop a like if it was and have a great day bye-bye
2025-07-11 03:06:04,731 - INFO - Transcript is successfully fetched by api.
2025-07-11 03:06:04,739 - INFO - Chunks has been successfully created.
2025-07-11 03:06:04,743 - INFO - Use pytorch device_name: cpu
2025-07-11 03:06:04,743 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-07-11 03:06:13,528 - INFO - chunks has been successfully stored in vector database.
2025-07-11 03:06:13,528 - INFO - {0: '1af7cd1a-951b-47b3-b2e1-f991c2521de3', 1: 'a2372c79-655a-4584-9b80-70b152f0269e', 2: 'cbab7a98-75e3-4cbd-8ff7-11ee1fc5462e', 3: '4c711ae0-e385-4e75-82f9-ca5729132cd2', 4: '45189b5f-3e38-4d7a-9f53-796261fdcbd0', 5: '9897e90c-0f0e-441b-8acc-35a53e14bf67', 6: '62e552ab-ba55-432c-a1c2-2ad90b2d7e4e', 7: 'f38af081-d7d4-443e-a1c3-1c663a5cbd4f', 8: '0e3a923c-a527-47e0-ae05-5f25bb9ffcf1', 9: '9ecbcfea-4fd7-4000-b59e-bb2ae83cd414', 10: 'f4ec47b9-3f6b-44cc-b002-f12199661064', 11: 'd6b24c30-51f1-40d8-a9d8-5881ab47deca', 12: '954d146d-5bfa-411c-8508-759c717c2a2e', 13: '83f85e8c-b674-48be-9d51-f66b4833ff83', 14: '88eb59f6-aaf6-4695-89a7-6deb61a0de52', 15: 'f7fb1883-ffb9-4c27-b470-1d3920dc873e', 16: 'f41ba15a-1049-497a-9295-9e1b53f5b0c3', 17: 'd243249f-cbeb-4421-978a-72a23d51ef7f', 18: '140942a5-a5a9-4838-b068-0dc0f3fccac3', 19: '742dd05f-32fd-4559-ad88-aeb0cb34e394', 20: '28761f2f-f839-4ef0-bea4-31e3bc2517c6', 21: 'e4532e5e-0eb7-42fd-b0f0-be7f29a42668', 22: 'd53c47a6-8c45-4d91-adba-d643bcb263b4', 23: 'df96ac6c-4021-4ee8-853d-bc5d0e0ef445', 24: '1bf700e1-2872-47d9-b9c2-def31b912a85', 25: '1274bb68-8c97-4356-b552-26684678d8b2', 26: '2026b092-96f4-4be4-a0bf-4593cf1e8741', 27: 'a06e126d-f8fb-460e-8ffe-713a862e641e', 28: '327fc5b7-e2de-454c-bbd8-a270d36950a9', 29: '3029df12-4425-4694-b7df-87cc06747689', 30: 'c69dd51b-714f-44de-af56-d1bb814aea2a', 31: '87a4a124-9378-44c0-8f4f-3fe43ede8f22', 32: '22d32088-b144-46b1-986d-e1246eeb4c78', 33: 'e5456e5f-12f7-4ae7-b39b-79b95f87c9f7', 34: 'c2e547e0-b11b-453a-ab5f-d9c1029bdb29', 35: 'acc9b88d-ddc0-4f48-a193-39291a76f3b3', 36: 'f238765e-7c30-4ea5-8b90-6b51c892b925', 37: 'b4c5b55d-49df-4212-a491-272cd8086789', 38: '9a72b675-738f-4dab-8e4a-7fb9349582ca', 39: 'dc40109a-b317-49a4-8e53-81685a5ea783', 40: '53d829b0-e55e-451a-b0e5-70133aeeed6f', 41: '6422ccee-bebf-4582-a6b3-f9497c5e6cc6', 42: '4035b386-aa8c-4255-9992-3cb6c55fa829', 43: '06f7c249-c3cd-4c8a-9c49-2025e7f23f7c', 44: 'bd9d102b-358b-4a1f-99f4-08faa5cbc361', 45: '14886d70-e90e-4ff9-bbd2-7e199b14f686'}
2025-07-11 03:06:13,528 - INFO - length of chunks: 46
2025-07-11 03:06:13,529 - INFO - Retriever is working good.
2025-07-11 03:06:13,530 - INFO - 
 
 Token is: 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 
 

2025-07-11 03:06:23,495 - INFO - Transcript : hey guys Greg here let's talk about linked lists today and there's two types of them there's singly linked lists as well as doubly linked lists now in picture form a singly linked list might look something like this which is basically circles with values in them and then they point to other circles with the values so we have one pointing to two which points to three and the three actually points over to nothing and that's important because that kind of signifies here that this is the end of the list okay so we'd call this a singly linked list basically because there's this single connection here between the nodes later on we'll see a doubly link list that would basically just be this where we have the backwards link as well but this is called a singly linked list where basically each of these things generally you call them a linked list node or in short form you generally just call them a node so a node is like an object and it has a couple different features to it one it has some sort of memory address as to where it's located in the computer so this is not like an array where an array is like a contiguous sequence of computer memory this is not the case here we actually have this as some sort of address which is going to be some hex code it doesn't really matter what this is here just know that it's some memory address and I'll just kind of short form this to be a so it's the memory address of a and this one would have a completely different memory address likely even very far away in the computer memory of B and this one might be called C and this last thing here what it's pointing over to is generally in a programming language something like null so you might see it be called null in Python we generally have that called none whatever it is it's just some programming language specific that says a special marker saying this is the end of the list okay so what actually is a linked list node well in a computer programming language we have these things called classes okay and classes create these things called objects so basically you would have some sort of thing called like a class node object it would have a value as you can see here it clearly has a node. value we'll write it like that and it also has a node. next so node. next is basically a reference to a different object if we were talking about this guy here well then it would have a next of basically the address of B saying that its next address is pointing over to B and what that allows us to do if you have a its next is pointing over to B and its next is C and its next is none well then this forms a chain because we can basically start here generally you would have some sort of a reference to the head of the linked list which is going to be the front of it so given this reference to the head here well then we can basically go through the list here until we hit none now this is basically an alternative way to store data compared to say an array where an array has certain elements like if you were to ask what is the array at maybe an index of five well in O of one time that array would tell you what is at position five but that's not a thing for a linked list here you can't say what is at the index these things don't have indices generally what we're given is the head to the linked list and to find any of the different elements in here you'd actually have to Traverse the list to do that now by the way here we're storing just the values of 1 2 and three but you can pretty much store any type of data you want in one of those linked list nodes but for lead code style problems they generally just kind of have the numbers there okay so there's a few different things you might want to do with a linked list for example if you wanted to add a new node at an arbitrary positions so maybe add a node at the position of two for example well we don't really have positions here like an array but you could still think of it as this is say the first spot this is the second spot and the third spot and we'll say that we're adding the Noe of a value of five you'd have to start at your head because that's generally all that you're given you're not actually generally given a b and c here and so to add the node at position two you would have to Traverse the list from the start until you got to that position and then you could put that Noe in there you would want one to point over to the five so you'd have to change one to point that over to five and then you'd have to point the five over to the two a general and O of n operation because you have to start at the head of the linked list Traverse to get to that position and then you can adjust it now similarly if you wanted to instead delete a node at position 2 well then you'd have to start at the beginning pretty much like always and then you'd have to go through until you you get to that position and basically just remove it which would involve pointing the previous one over to the next one like that and then you could think of your positions as adjusted like this so 1 2 and three okay so again that's going to be an oent operation cuz you start at the beginning and go up until that position now even more simply if you wanted to just say access a node at a certain position so you didn't want to remove or add it you just wanted to kind of look what's there well again you'd kind of have to start at the beginning and go up until that position to kind of read that element so again an oent thing to do now an operation we generally perform on pretty much every single data structure that we have is lookup so in this case it would be seeing if a certain value is in the linked list okay so you could probably guess that's going to be an oent operation because in the worst case you would have to go through the entire list and have not found it or if you were looking up say something like two well then you would go through and see that two is there but still that's going to be an O of n thing to do now there is a couple things that are o of One op operations so one thing that linked lists are really good at is if you are talking about the beginning of the list so if you wanted to basically remove the thing at the beginning well then that is going to be an O of one operation because basically you would just kind of Point your head element over to this second position here so that would effectively just remove this and then you could think of your positions as one and two although I'm going to stop kind of writing the positions because they don't really exist if you wanted to add a new head so if all you wanted to do is kind of put some something at the very beginning well then yeah that's also going to be o of one you'd basically Point your head over to that new element and then you would Point your new element over to that one so that's also going to be o of one and if you particularly happen to have the reference to say the node here so maybe you happen to have node C over here and you wanted to say remove that what's kind of tricky about this is that if you just kind of remove this given access to node C well then how do you actually change where this node points to because it's sing linked list and so just given C you don't actually have the ability to adjust this one here you want to adjust this next pointer except you don't have that because you just have this node so that's why in practice a lot of the time we actually switch over to doubly link lists which is basically going to be the exact same thing here except we have the reverse connection and our head would actually Point reverse Direction over to none as well so basically saying we have a head element so we still have a head which I'm just going to Mark as h and we also kind of have access immediately to this tail so generally now instead of just access to the front you also have access to the back via the tail and we can kind of go both directions here you could Traverse through this way or you could Traverse backwards so this is a doubly linked list and by the way how this might look in a programming language is you might have a class node which is basically going to have three things now it would have basically a node do value so what it's storing it would have a no. next these are the exact same things as before but then you also might have a node. previous basically saying that each node here they all have a next pointer and they also have a previous pointer and sometimes I might say pointer sometimes I might say reference if you really truly want to understand the whole pointer thing then you'd want to take a class in C but from a python perspective it's basically just that node. nextext is like a reference to a node object and node. preve would be a reference to a node object as well now one thing the W link list does help with is if you had say a reference to this node here you had that if you wanted to delete that so basically if you wanted to delete node B well then you actually only need access to this node here because from this node you could actually access this one because you have the connection to it and you could also access this one so you could actually remove it because basically what you'd have to do is point this previous thing over to the next one and you'd have to point its next one basically back over to the previous one so this does allow basically deleting an element at a particular reference that would actually be constant although we often don't have that ability because generally you only have access to the head and the tail sometimes you have access to kind of the middle node references okay so let's see how we can work with singly and doubly linked lists in Python okay let's start with singly linked lists here so we need a class that makes a node we'll call it singly node and so for the Constructor here now they're going to take a value and they're going to take a next pointer so what it's pointing over to and by default this is just none or null okay and all the Constructor is going to do is just set that its value is the value passed in and the next pointer is the next passed in okay then we'll just give it a simple print method so we can print one of these that is the string method so underscore string like that and this just returns some sort of a string representation so this is going to be the string of the self. Val so we take whatever the V is we just convert that to a string and that's how this thing is going to print okay then to make a linked list you generally have reference only to the head so we'll call it head that's going to be a singly node which just has a value of one now by default this will make the next pointer just none but we'll set those explicitly in a moment we'll get three other nodes I'll call it a is the singly node of three and B is the singly node of four and C is the singly node of seven so we now have four different nodes where the head is one okay now to actually join these things up here by default we kind of just have these floating around in space we want to connect them up so head. next is equal to a points head over to a then a do next is equal to B and b. nextt is equal to C so now we have the connection of head points over to a which points over to B which points over to C and then C is still pointing over to nothing and for now we can just print the head of the list although that's not going to show the full list it's just going to show the value of the first node okay now one thing we usually want to do this is the most common pattern with length lists is some sort of Travers veral so in general just to Traverse the list print the values to Traverse the list this is going to be of course an O of n operation cuz we're visiting all the nodes then you generally get a variable called something like cerr and we'll point that at the head and we keep moving cerr over so while we have Curr so basically until cerr turns into none we will print the current node and then we are going to just move cerr over so we set cerr equal to c. next this effectively traverses cerr throughout the entire linked list until cerr hits the node of C then it's going to point to c. next which is null it'll end the while loop and so if we're just to run this here we'll see 1 3 47 so most linked list problems will be some sort of pattern where you Traverse the list now something that's going to prove very useful is being able to display it well so just basically displaying the linked list and this is going to take definitely o of n time we're going to call that a function display which takes a head so again we'll get a pointer or variable Curr is equal to the Head we'll build up a list of elements so elements is going to be a dynamic array or a list and then while we have Curr well we have one more element so we'd elements. append add that to the array we'll give it the string of the current Dov value and then we would just move C over so C is equal to c. next now after this Loop concludes we'd eventually have Curr is none and so what we want to do is print the string of the arrow like this and note the spaces so that it looks good do join up the elements so if you haven't seen join before basically what that would do do is given a list of strings so something like this A and B and C well join is going to move them into the string of just ABC but this thing here is what you kind of call a glue it's how it glues them together then when you join them it's going to kind of move them like this so it'll glue them together so it ends up looking like this so that's exactly what this does here if you display so display the original head that's going to show the link list very pretty like that okay now something you might want to do is search for a node so search sech for a node value and that's going to take o of n time so to do that we'll Define a function called search which again takes a head and it's also going to take a value to look for this pattern comes up all the time C is equal to head and then while we have C if the Val we're looking for is equal to the current value well then that means we found it and so we would return true if that wasn't the case then we need to keep looking so we set Cur equal to c. next and if this Loop ever concludes it means that we didn't find it and so we would return false at this level so let's just search for a few things here if we search for the value of two sorry you have to give that the head so search for head and two that is going to show up false we don't have that if you have nine that is also not the case if you have something that is in there like the head of one or the tail of seven clearly our search function works okay there's lots of exciting algorithms to learn about linked lists but you can learn those in the leak code problems okay now we're going to do doubly linked lists so for that again we'd have a class which is called doubly node so we have the forward and backward connection it takes a value that the node is going to be it takes a next pointer by default it's going to be none and it also has a previous which by default is going to be set to none okay then all it's going to do is just set the self. fou equal to the Past in fou and the next is going to be the next and the prieve is going to be the preve and we'll just give it a simple printing function so we'll Define underscore uncore string it's just going to return the string of the self. value the exact same as the previous okay then how we can work with this thing is you need access to both the head and the tail so we'll get head is equal to tail which is equal to a dou node and will give that the value of one if you print the head that should show you that the value is one and if you print the tail they're pointing to the same thing so this is also one so we'll Define a function call it display that takes just the head of the linked list you don't need the tail for this so we'll get Cur is equal to the head our elements is our list and again while we have cerr we want to elements. append the string of the C.V so exactly the same thing and we'd set c equal to c. next and then after we get out of here we just want to print with a different glue so we would print with the double connection like this implying we have forwards and backwards because we do so do join that up with the elements and if we were to run display just on our original head display the head we can see it's just one and that's totally accurate for now we just have one node so we want a function that inserts inserts at the beginning basically meaning getting a new head and that's going to be o of one so we'll Define a function called insert at beginning and that's going to take the head it's also going to take the tail and it's going to take the value that you want the new head to be so you would get a new node which is equal to a doubly node reference so we make a new node if you remember how our class looks here it is the value then next then previous so we want the value to be the value and we want to specifically specify that the next is equal to the head because it's saying that we're making a new node and we want that to be the value that we have we want this to point over to the Head the only thing we'd have to do here is set head. preve so our old head equal to the new node so before the head was basically pointing over to null because it was the head but now we want it to put in the middle pointing it to the new node we just made okay so we would return new node and the tail because this is our new head and the tail stay the same and then you would call this like with head and tail is equal to insert at beginning you'd give it the current head the current Tail as well as a new value and we'll give it the value of three so if we do that and then display our head well this is going to show that we have three at the beginning that made a new head and it points over to the one as the tail now if understanding this function was a little bit tricky that's the whole point of the lead code linked list problems is to get comfortable with drawing and then coding this idea okay similarly we could also do insert at end and I'm just kind of going to copy that and explain that for you we can insert at the end in O of one time where you give the head the tail and a new value you'd make a new node which is going to take that new value and you'd point that new node back over to the tail so that would point it left over to the old tail and then you would just need to update that your old tail is then going to point right over to your new node so this basically makes a new tail and so we'd return the head and the new tail and so if we were to run this with a value of seven we're going to see we have a new tail of seven okay as always you can get this code in the video description deson if you'd like to see it I hope this was helpful guys drop a like if it was and have a great day bye-bye
2025-07-11 03:06:23,495 - INFO - Transcript is successfully fetched by api.
2025-07-11 03:06:23,501 - INFO - Chunks has been successfully created.
2025-07-11 03:06:23,503 - INFO - Use pytorch device_name: cpu
2025-07-11 03:06:23,504 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-07-11 03:06:34,957 - INFO - chunks has been successfully stored in vector database.
2025-07-11 03:06:34,957 - INFO - {0: 'a95ada40-06fd-44ce-a22b-89e75e387f41', 1: '8e84fab1-362c-4cb3-8ab0-d378c3677760', 2: 'c3733677-d817-4146-9ac7-11620a1933b6', 3: 'c84f366f-caac-43ed-a220-e1734545cabc', 4: 'ddbac07d-2bfa-40c8-94bb-1315b3f6b0a0', 5: '0d3bef09-2f9b-4927-b89b-cb9a57306d16', 6: '15998d77-e28a-409e-b5e3-157f4dd7dac2', 7: 'ab8a8292-f08b-477e-aaad-5abda3aef99b', 8: '65882aa4-9fd5-4a37-ac7b-afcccb9d5fdf', 9: '7e0ae2b1-b4df-403e-9a00-3dd9f32e1b49', 10: '97746ce5-485a-4015-b9b8-892149a9fc5a', 11: 'e8ce32b2-0e02-4f5e-a7f4-55800c272013', 12: '424e8c3e-067e-4732-a926-2c8bc8b0caa5', 13: '6445068d-5eb3-4d7e-a1ea-8be54d2a7d17', 14: 'f0ae1c60-e4ae-44aa-9c0d-30e48419f8d2', 15: '9fa5386d-0218-453a-a906-0a4c0fd931ff', 16: '3de6ed34-85cf-4ff9-8c4d-cf5be39d42e6', 17: '55466bc1-741d-44f7-a388-d411f53fdd0b', 18: '08052781-878e-435d-a9eb-9afb84ed76ac', 19: '5f69203c-74f8-434a-95d9-a9d5a92e5065', 20: 'd71c8b16-18e6-4326-83d6-5be1c721bec1', 21: '99174595-7d04-4512-8c29-35958962f638', 22: '0678dc08-b667-4a36-9b29-66dc7140be9e', 23: '6f21a4a9-e360-471d-b8e1-8c9047e34371', 24: '4bd8c19b-3165-4120-b28d-1d9950b0efa0', 25: '8ede0042-d806-4448-bab9-6b9ccf15f567', 26: '0f56e4fb-ed00-44f1-9e0f-2c30b800b422', 27: '21b5a372-ec36-4ee4-b66d-454ca48a5cd6', 28: '46432e4f-2b11-40c7-8f96-207ff9660469', 29: '0cad960a-dc7e-4917-a315-e2cb42c1d0ca', 30: 'cea80ef4-0b27-4920-820d-eea9af41646c', 31: '4d78ca33-ad6f-4162-833a-c3c9d683ff2d', 32: 'c28649a7-ae71-4f09-b41d-47d450972f8a', 33: 'ec6bf302-157b-408f-9d64-d4907edba32b', 34: 'f5c929fe-2791-408e-8598-4390a2bd98f3', 35: 'b39d2211-129b-47ab-bbdd-6fa1dfd4f4f5', 36: '5bca0c62-ed15-48cf-ad45-adf4eede2775', 37: 'f2763165-8359-43ab-a3b0-f316064f52d4', 38: 'dea2c9d5-ba76-44de-95b0-717a797c86b8', 39: '2ec29805-9771-4243-a9d2-3a648e99087a', 40: '25ba38c2-bda2-4366-ae1c-6a8715fd3cc1', 41: '2ee35b74-ac14-427b-9ff4-ae58b7f180f2', 42: '5f64e7ed-b402-4baf-83f8-7cb1c858fc11', 43: '9fefbfeb-8249-45d8-b55b-068c65057121', 44: '00486e7e-d470-4de8-8056-6f04fccf43bf', 45: '986d1b81-54f2-442c-b678-96da16e49f44'}
2025-07-11 03:06:34,957 - INFO - length of chunks: 46
2025-07-11 03:06:34,958 - INFO - Retriever is working good.
2025-07-11 03:06:34,959 - INFO - 
 
 Token is: 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 
 

2025-07-11 03:18:38,994 - INFO - Transcript : hey guys Greg here let's talk about linked lists today and there's two types of them there's singly linked lists as well as doubly linked lists now in picture form a singly linked list might look something like this which is basically circles with values in them and then they point to other circles with the values so we have one pointing to two which points to three and the three actually points over to nothing and that's important because that kind of signifies here that this is the end of the list okay so we'd call this a singly linked list basically because there's this single connection here between the nodes later on we'll see a doubly link list that would basically just be this where we have the backwards link as well but this is called a singly linked list where basically each of these things generally you call them a linked list node or in short form you generally just call them a node so a node is like an object and it has a couple different features to it one it has some sort of memory address as to where it's located in the computer so this is not like an array where an array is like a contiguous sequence of computer memory this is not the case here we actually have this as some sort of address which is going to be some hex code it doesn't really matter what this is here just know that it's some memory address and I'll just kind of short form this to be a so it's the memory address of a and this one would have a completely different memory address likely even very far away in the computer memory of B and this one might be called C and this last thing here what it's pointing over to is generally in a programming language something like null so you might see it be called null in Python we generally have that called none whatever it is it's just some programming language specific that says a special marker saying this is the end of the list okay so what actually is a linked list node well in a computer programming language we have these things called classes okay and classes create these things called objects so basically you would have some sort of thing called like a class node object it would have a value as you can see here it clearly has a node. value we'll write it like that and it also has a node. next so node. next is basically a reference to a different object if we were talking about this guy here well then it would have a next of basically the address of B saying that its next address is pointing over to B and what that allows us to do if you have a its next is pointing over to B and its next is C and its next is none well then this forms a chain because we can basically start here generally you would have some sort of a reference to the head of the linked list which is going to be the front of it so given this reference to the head here well then we can basically go through the list here until we hit none now this is basically an alternative way to store data compared to say an array where an array has certain elements like if you were to ask what is the array at maybe an index of five well in O of one time that array would tell you what is at position five but that's not a thing for a linked list here you can't say what is at the index these things don't have indices generally what we're given is the head to the linked list and to find any of the different elements in here you'd actually have to Traverse the list to do that now by the way here we're storing just the values of 1 2 and three but you can pretty much store any type of data you want in one of those linked list nodes but for lead code style problems they generally just kind of have the numbers there okay so there's a few different things you might want to do with a linked list for example if you wanted to add a new node at an arbitrary positions so maybe add a node at the position of two for example well we don't really have positions here like an array but you could still think of it as this is say the first spot this is the second spot and the third spot and we'll say that we're adding the Noe of a value of five you'd have to start at your head because that's generally all that you're given you're not actually generally given a b and c here and so to add the node at position two you would have to Traverse the list from the start until you got to that position and then you could put that Noe in there you would want one to point over to the five so you'd have to change one to point that over to five and then you'd have to point the five over to the two a general and O of n operation because you have to start at the head of the linked list Traverse to get to that position and then you can adjust it now similarly if you wanted to instead delete a node at position 2 well then you'd have to start at the beginning pretty much like always and then you'd have to go through until you you get to that position and basically just remove it which would involve pointing the previous one over to the next one like that and then you could think of your positions as adjusted like this so 1 2 and three okay so again that's going to be an oent operation cuz you start at the beginning and go up until that position now even more simply if you wanted to just say access a node at a certain position so you didn't want to remove or add it you just wanted to kind of look what's there well again you'd kind of have to start at the beginning and go up until that position to kind of read that element so again an oent thing to do now an operation we generally perform on pretty much every single data structure that we have is lookup so in this case it would be seeing if a certain value is in the linked list okay so you could probably guess that's going to be an oent operation because in the worst case you would have to go through the entire list and have not found it or if you were looking up say something like two well then you would go through and see that two is there but still that's going to be an O of n thing to do now there is a couple things that are o of One op operations so one thing that linked lists are really good at is if you are talking about the beginning of the list so if you wanted to basically remove the thing at the beginning well then that is going to be an O of one operation because basically you would just kind of Point your head element over to this second position here so that would effectively just remove this and then you could think of your positions as one and two although I'm going to stop kind of writing the positions because they don't really exist if you wanted to add a new head so if all you wanted to do is kind of put some something at the very beginning well then yeah that's also going to be o of one you'd basically Point your head over to that new element and then you would Point your new element over to that one so that's also going to be o of one and if you particularly happen to have the reference to say the node here so maybe you happen to have node C over here and you wanted to say remove that what's kind of tricky about this is that if you just kind of remove this given access to node C well then how do you actually change where this node points to because it's sing linked list and so just given C you don't actually have the ability to adjust this one here you want to adjust this next pointer except you don't have that because you just have this node so that's why in practice a lot of the time we actually switch over to doubly link lists which is basically going to be the exact same thing here except we have the reverse connection and our head would actually Point reverse Direction over to none as well so basically saying we have a head element so we still have a head which I'm just going to Mark as h and we also kind of have access immediately to this tail so generally now instead of just access to the front you also have access to the back via the tail and we can kind of go both directions here you could Traverse through this way or you could Traverse backwards so this is a doubly linked list and by the way how this might look in a programming language is you might have a class node which is basically going to have three things now it would have basically a node do value so what it's storing it would have a no. next these are the exact same things as before but then you also might have a node. previous basically saying that each node here they all have a next pointer and they also have a previous pointer and sometimes I might say pointer sometimes I might say reference if you really truly want to understand the whole pointer thing then you'd want to take a class in C but from a python perspective it's basically just that node. nextext is like a reference to a node object and node. preve would be a reference to a node object as well now one thing the W link list does help with is if you had say a reference to this node here you had that if you wanted to delete that so basically if you wanted to delete node B well then you actually only need access to this node here because from this node you could actually access this one because you have the connection to it and you could also access this one so you could actually remove it because basically what you'd have to do is point this previous thing over to the next one and you'd have to point its next one basically back over to the previous one so this does allow basically deleting an element at a particular reference that would actually be constant although we often don't have that ability because generally you only have access to the head and the tail sometimes you have access to kind of the middle node references okay so let's see how we can work with singly and doubly linked lists in Python okay let's start with singly linked lists here so we need a class that makes a node we'll call it singly node and so for the Constructor here now they're going to take a value and they're going to take a next pointer so what it's pointing over to and by default this is just none or null okay and all the Constructor is going to do is just set that its value is the value passed in and the next pointer is the next passed in okay then we'll just give it a simple print method so we can print one of these that is the string method so underscore string like that and this just returns some sort of a string representation so this is going to be the string of the self. Val so we take whatever the V is we just convert that to a string and that's how this thing is going to print okay then to make a linked list you generally have reference only to the head so we'll call it head that's going to be a singly node which just has a value of one now by default this will make the next pointer just none but we'll set those explicitly in a moment we'll get three other nodes I'll call it a is the singly node of three and B is the singly node of four and C is the singly node of seven so we now have four different nodes where the head is one okay now to actually join these things up here by default we kind of just have these floating around in space we want to connect them up so head. next is equal to a points head over to a then a do next is equal to B and b. nextt is equal to C so now we have the connection of head points over to a which points over to B which points over to C and then C is still pointing over to nothing and for now we can just print the head of the list although that's not going to show the full list it's just going to show the value of the first node okay now one thing we usually want to do this is the most common pattern with length lists is some sort of Travers veral so in general just to Traverse the list print the values to Traverse the list this is going to be of course an O of n operation cuz we're visiting all the nodes then you generally get a variable called something like cerr and we'll point that at the head and we keep moving cerr over so while we have Curr so basically until cerr turns into none we will print the current node and then we are going to just move cerr over so we set cerr equal to c. next this effectively traverses cerr throughout the entire linked list until cerr hits the node of C then it's going to point to c. next which is null it'll end the while loop and so if we're just to run this here we'll see 1 3 47 so most linked list problems will be some sort of pattern where you Traverse the list now something that's going to prove very useful is being able to display it well so just basically displaying the linked list and this is going to take definitely o of n time we're going to call that a function display which takes a head so again we'll get a pointer or variable Curr is equal to the Head we'll build up a list of elements so elements is going to be a dynamic array or a list and then while we have Curr well we have one more element so we'd elements. append add that to the array we'll give it the string of the current Dov value and then we would just move C over so C is equal to c. next now after this Loop concludes we'd eventually have Curr is none and so what we want to do is print the string of the arrow like this and note the spaces so that it looks good do join up the elements so if you haven't seen join before basically what that would do do is given a list of strings so something like this A and B and C well join is going to move them into the string of just ABC but this thing here is what you kind of call a glue it's how it glues them together then when you join them it's going to kind of move them like this so it'll glue them together so it ends up looking like this so that's exactly what this does here if you display so display the original head that's going to show the link list very pretty like that okay now something you might want to do is search for a node so search sech for a node value and that's going to take o of n time so to do that we'll Define a function called search which again takes a head and it's also going to take a value to look for this pattern comes up all the time C is equal to head and then while we have C if the Val we're looking for is equal to the current value well then that means we found it and so we would return true if that wasn't the case then we need to keep looking so we set Cur equal to c. next and if this Loop ever concludes it means that we didn't find it and so we would return false at this level so let's just search for a few things here if we search for the value of two sorry you have to give that the head so search for head and two that is going to show up false we don't have that if you have nine that is also not the case if you have something that is in there like the head of one or the tail of seven clearly our search function works okay there's lots of exciting algorithms to learn about linked lists but you can learn those in the leak code problems okay now we're going to do doubly linked lists so for that again we'd have a class which is called doubly node so we have the forward and backward connection it takes a value that the node is going to be it takes a next pointer by default it's going to be none and it also has a previous which by default is going to be set to none okay then all it's going to do is just set the self. fou equal to the Past in fou and the next is going to be the next and the prieve is going to be the preve and we'll just give it a simple printing function so we'll Define underscore uncore string it's just going to return the string of the self. value the exact same as the previous okay then how we can work with this thing is you need access to both the head and the tail so we'll get head is equal to tail which is equal to a dou node and will give that the value of one if you print the head that should show you that the value is one and if you print the tail they're pointing to the same thing so this is also one so we'll Define a function call it display that takes just the head of the linked list you don't need the tail for this so we'll get Cur is equal to the head our elements is our list and again while we have cerr we want to elements. append the string of the C.V so exactly the same thing and we'd set c equal to c. next and then after we get out of here we just want to print with a different glue so we would print with the double connection like this implying we have forwards and backwards because we do so do join that up with the elements and if we were to run display just on our original head display the head we can see it's just one and that's totally accurate for now we just have one node so we want a function that inserts inserts at the beginning basically meaning getting a new head and that's going to be o of one so we'll Define a function called insert at beginning and that's going to take the head it's also going to take the tail and it's going to take the value that you want the new head to be so you would get a new node which is equal to a doubly node reference so we make a new node if you remember how our class looks here it is the value then next then previous so we want the value to be the value and we want to specifically specify that the next is equal to the head because it's saying that we're making a new node and we want that to be the value that we have we want this to point over to the Head the only thing we'd have to do here is set head. preve so our old head equal to the new node so before the head was basically pointing over to null because it was the head but now we want it to put in the middle pointing it to the new node we just made okay so we would return new node and the tail because this is our new head and the tail stay the same and then you would call this like with head and tail is equal to insert at beginning you'd give it the current head the current Tail as well as a new value and we'll give it the value of three so if we do that and then display our head well this is going to show that we have three at the beginning that made a new head and it points over to the one as the tail now if understanding this function was a little bit tricky that's the whole point of the lead code linked list problems is to get comfortable with drawing and then coding this idea okay similarly we could also do insert at end and I'm just kind of going to copy that and explain that for you we can insert at the end in O of one time where you give the head the tail and a new value you'd make a new node which is going to take that new value and you'd point that new node back over to the tail so that would point it left over to the old tail and then you would just need to update that your old tail is then going to point right over to your new node so this basically makes a new tail and so we'd return the head and the new tail and so if we were to run this with a value of seven we're going to see we have a new tail of seven okay as always you can get this code in the video description deson if you'd like to see it I hope this was helpful guys drop a like if it was and have a great day bye-bye
2025-07-11 03:18:38,994 - INFO - Transcript is successfully fetched by api.
2025-07-11 03:18:38,999 - INFO - Chunks has been successfully created.
2025-07-11 03:18:39,002 - INFO - Use pytorch device_name: cpu
2025-07-11 03:18:39,002 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-07-11 03:18:51,328 - INFO - chunks has been successfully stored in vector database.
2025-07-11 03:18:51,329 - INFO - {0: '132f7d42-fa6f-4046-b610-b4596a17e06f', 1: 'afe9ce68-48ee-4e95-b9bb-7d1fcce4df0d', 2: 'bebfa200-7cec-469a-920f-5976f8852e01', 3: '8448f4c2-07b2-4812-a14e-72d970fb44c4', 4: '0d6a8492-15f6-4357-9a70-139934c4a1da', 5: '96707338-5e4f-45fe-9f17-2a8dc3524262', 6: '4c7f210f-2766-49e1-9bdb-02635a2f8416', 7: '62f0e9cc-2d17-4c39-84b2-cc866f8b831b', 8: '32ff7c4b-a3d7-4763-92f9-dc34cab10baf', 9: '52bf5f01-883b-429e-957d-1e74864165f9', 10: '3d7c4388-3643-4015-8dc7-5addbbee0928', 11: 'fb86a00d-07f9-4b7c-b63a-c37e4bf38eda', 12: 'c3284293-d65a-4730-9012-ff6a0f3b12b1', 13: '9808e7e2-7c07-442d-869b-b0c87b52673e', 14: '3fc3326e-b98b-4213-a7d8-588824e5fc33', 15: '0f679d9b-1bf2-4629-bb2f-6eef13d5d038', 16: 'b50611bc-4526-4f83-afe7-58abd6d938b2', 17: '4b7140d9-03f8-4440-a932-99334237cb00', 18: '627629d7-741d-4cbf-bf09-304705c25793', 19: 'e52dcfb1-1645-496a-9f2d-7290303d42f9', 20: 'd72e90d7-e01f-44ab-93a0-05b9f0292f5b', 21: 'e9fb9895-be43-4b49-8eab-9fb0bbbc760f', 22: '8a8dc50e-11d6-4233-81b3-883c72d3028a', 23: 'be69efb2-9441-404f-8831-fa04373a4797', 24: '335d3193-3e1e-4354-a620-e2bb06b59080', 25: '4958c58d-01ba-44f1-8833-6ae8621b6928', 26: '98da0ddd-0f22-44da-852a-be39fee13407', 27: '47236690-3d8f-43c3-8051-ea925b24725f', 28: '5eac5bc5-58d1-4f78-aa12-8524f403419b', 29: '12e1e892-6936-4dbe-81ba-8ced62002cc5', 30: '3a882cac-c385-49b2-846d-11a32e8ae3b3', 31: '596519fb-8f9c-4681-aa7a-3afdf7ba305c', 32: '8e66bc20-6054-4a12-b51f-9286cf790637', 33: 'f32829a0-7022-4992-b91f-44d581125fd8', 34: '3ba797bc-ea5c-4bab-8984-2141f6f4becd', 35: 'f8944b8a-0295-4230-9651-df3a50e245c1', 36: 'eeb1cb7f-c324-4e11-b32b-80a601760622', 37: 'f5dbbe59-76d3-4ddd-b37a-d58e292079b6', 38: '23d724d8-711c-49b1-b622-bfb4eb2b98c3', 39: '60cbda55-a487-420d-8b49-440962ab6f83', 40: '1e1b8a0e-0a26-4f26-81e6-e7d2cddebbf9', 41: '0c196b0c-0f9a-473c-bb3b-005197b892d4', 42: '28fe1b65-bc09-4eb5-9843-9c41c9538ff0', 43: '3abb5e83-e79b-4516-8bf7-41b6686e3d67', 44: '83535f06-c445-4705-89e2-45d1ee61debb', 45: '9ae881be-2408-4887-8ce0-075546d112e3'}
2025-07-11 03:18:51,329 - INFO - length of chunks: 46
2025-07-11 03:18:51,330 - INFO - Retriever is working good.
2025-07-11 03:18:51,331 - INFO - 
 
 Token is: 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 
 

2025-07-11 03:19:10,864 - INFO - Transcript : hey guys Greg here let's talk about linked lists today and there's two types of them there's singly linked lists as well as doubly linked lists now in picture form a singly linked list might look something like this which is basically circles with values in them and then they point to other circles with the values so we have one pointing to two which points to three and the three actually points over to nothing and that's important because that kind of signifies here that this is the end of the list okay so we'd call this a singly linked list basically because there's this single connection here between the nodes later on we'll see a doubly link list that would basically just be this where we have the backwards link as well but this is called a singly linked list where basically each of these things generally you call them a linked list node or in short form you generally just call them a node so a node is like an object and it has a couple different features to it one it has some sort of memory address as to where it's located in the computer so this is not like an array where an array is like a contiguous sequence of computer memory this is not the case here we actually have this as some sort of address which is going to be some hex code it doesn't really matter what this is here just know that it's some memory address and I'll just kind of short form this to be a so it's the memory address of a and this one would have a completely different memory address likely even very far away in the computer memory of B and this one might be called C and this last thing here what it's pointing over to is generally in a programming language something like null so you might see it be called null in Python we generally have that called none whatever it is it's just some programming language specific that says a special marker saying this is the end of the list okay so what actually is a linked list node well in a computer programming language we have these things called classes okay and classes create these things called objects so basically you would have some sort of thing called like a class node object it would have a value as you can see here it clearly has a node. value we'll write it like that and it also has a node. next so node. next is basically a reference to a different object if we were talking about this guy here well then it would have a next of basically the address of B saying that its next address is pointing over to B and what that allows us to do if you have a its next is pointing over to B and its next is C and its next is none well then this forms a chain because we can basically start here generally you would have some sort of a reference to the head of the linked list which is going to be the front of it so given this reference to the head here well then we can basically go through the list here until we hit none now this is basically an alternative way to store data compared to say an array where an array has certain elements like if you were to ask what is the array at maybe an index of five well in O of one time that array would tell you what is at position five but that's not a thing for a linked list here you can't say what is at the index these things don't have indices generally what we're given is the head to the linked list and to find any of the different elements in here you'd actually have to Traverse the list to do that now by the way here we're storing just the values of 1 2 and three but you can pretty much store any type of data you want in one of those linked list nodes but for lead code style problems they generally just kind of have the numbers there okay so there's a few different things you might want to do with a linked list for example if you wanted to add a new node at an arbitrary positions so maybe add a node at the position of two for example well we don't really have positions here like an array but you could still think of it as this is say the first spot this is the second spot and the third spot and we'll say that we're adding the Noe of a value of five you'd have to start at your head because that's generally all that you're given you're not actually generally given a b and c here and so to add the node at position two you would have to Traverse the list from the start until you got to that position and then you could put that Noe in there you would want one to point over to the five so you'd have to change one to point that over to five and then you'd have to point the five over to the two a general and O of n operation because you have to start at the head of the linked list Traverse to get to that position and then you can adjust it now similarly if you wanted to instead delete a node at position 2 well then you'd have to start at the beginning pretty much like always and then you'd have to go through until you you get to that position and basically just remove it which would involve pointing the previous one over to the next one like that and then you could think of your positions as adjusted like this so 1 2 and three okay so again that's going to be an oent operation cuz you start at the beginning and go up until that position now even more simply if you wanted to just say access a node at a certain position so you didn't want to remove or add it you just wanted to kind of look what's there well again you'd kind of have to start at the beginning and go up until that position to kind of read that element so again an oent thing to do now an operation we generally perform on pretty much every single data structure that we have is lookup so in this case it would be seeing if a certain value is in the linked list okay so you could probably guess that's going to be an oent operation because in the worst case you would have to go through the entire list and have not found it or if you were looking up say something like two well then you would go through and see that two is there but still that's going to be an O of n thing to do now there is a couple things that are o of One op operations so one thing that linked lists are really good at is if you are talking about the beginning of the list so if you wanted to basically remove the thing at the beginning well then that is going to be an O of one operation because basically you would just kind of Point your head element over to this second position here so that would effectively just remove this and then you could think of your positions as one and two although I'm going to stop kind of writing the positions because they don't really exist if you wanted to add a new head so if all you wanted to do is kind of put some something at the very beginning well then yeah that's also going to be o of one you'd basically Point your head over to that new element and then you would Point your new element over to that one so that's also going to be o of one and if you particularly happen to have the reference to say the node here so maybe you happen to have node C over here and you wanted to say remove that what's kind of tricky about this is that if you just kind of remove this given access to node C well then how do you actually change where this node points to because it's sing linked list and so just given C you don't actually have the ability to adjust this one here you want to adjust this next pointer except you don't have that because you just have this node so that's why in practice a lot of the time we actually switch over to doubly link lists which is basically going to be the exact same thing here except we have the reverse connection and our head would actually Point reverse Direction over to none as well so basically saying we have a head element so we still have a head which I'm just going to Mark as h and we also kind of have access immediately to this tail so generally now instead of just access to the front you also have access to the back via the tail and we can kind of go both directions here you could Traverse through this way or you could Traverse backwards so this is a doubly linked list and by the way how this might look in a programming language is you might have a class node which is basically going to have three things now it would have basically a node do value so what it's storing it would have a no. next these are the exact same things as before but then you also might have a node. previous basically saying that each node here they all have a next pointer and they also have a previous pointer and sometimes I might say pointer sometimes I might say reference if you really truly want to understand the whole pointer thing then you'd want to take a class in C but from a python perspective it's basically just that node. nextext is like a reference to a node object and node. preve would be a reference to a node object as well now one thing the W link list does help with is if you had say a reference to this node here you had that if you wanted to delete that so basically if you wanted to delete node B well then you actually only need access to this node here because from this node you could actually access this one because you have the connection to it and you could also access this one so you could actually remove it because basically what you'd have to do is point this previous thing over to the next one and you'd have to point its next one basically back over to the previous one so this does allow basically deleting an element at a particular reference that would actually be constant although we often don't have that ability because generally you only have access to the head and the tail sometimes you have access to kind of the middle node references okay so let's see how we can work with singly and doubly linked lists in Python okay let's start with singly linked lists here so we need a class that makes a node we'll call it singly node and so for the Constructor here now they're going to take a value and they're going to take a next pointer so what it's pointing over to and by default this is just none or null okay and all the Constructor is going to do is just set that its value is the value passed in and the next pointer is the next passed in okay then we'll just give it a simple print method so we can print one of these that is the string method so underscore string like that and this just returns some sort of a string representation so this is going to be the string of the self. Val so we take whatever the V is we just convert that to a string and that's how this thing is going to print okay then to make a linked list you generally have reference only to the head so we'll call it head that's going to be a singly node which just has a value of one now by default this will make the next pointer just none but we'll set those explicitly in a moment we'll get three other nodes I'll call it a is the singly node of three and B is the singly node of four and C is the singly node of seven so we now have four different nodes where the head is one okay now to actually join these things up here by default we kind of just have these floating around in space we want to connect them up so head. next is equal to a points head over to a then a do next is equal to B and b. nextt is equal to C so now we have the connection of head points over to a which points over to B which points over to C and then C is still pointing over to nothing and for now we can just print the head of the list although that's not going to show the full list it's just going to show the value of the first node okay now one thing we usually want to do this is the most common pattern with length lists is some sort of Travers veral so in general just to Traverse the list print the values to Traverse the list this is going to be of course an O of n operation cuz we're visiting all the nodes then you generally get a variable called something like cerr and we'll point that at the head and we keep moving cerr over so while we have Curr so basically until cerr turns into none we will print the current node and then we are going to just move cerr over so we set cerr equal to c. next this effectively traverses cerr throughout the entire linked list until cerr hits the node of C then it's going to point to c. next which is null it'll end the while loop and so if we're just to run this here we'll see 1 3 47 so most linked list problems will be some sort of pattern where you Traverse the list now something that's going to prove very useful is being able to display it well so just basically displaying the linked list and this is going to take definitely o of n time we're going to call that a function display which takes a head so again we'll get a pointer or variable Curr is equal to the Head we'll build up a list of elements so elements is going to be a dynamic array or a list and then while we have Curr well we have one more element so we'd elements. append add that to the array we'll give it the string of the current Dov value and then we would just move C over so C is equal to c. next now after this Loop concludes we'd eventually have Curr is none and so what we want to do is print the string of the arrow like this and note the spaces so that it looks good do join up the elements so if you haven't seen join before basically what that would do do is given a list of strings so something like this A and B and C well join is going to move them into the string of just ABC but this thing here is what you kind of call a glue it's how it glues them together then when you join them it's going to kind of move them like this so it'll glue them together so it ends up looking like this so that's exactly what this does here if you display so display the original head that's going to show the link list very pretty like that okay now something you might want to do is search for a node so search sech for a node value and that's going to take o of n time so to do that we'll Define a function called search which again takes a head and it's also going to take a value to look for this pattern comes up all the time C is equal to head and then while we have C if the Val we're looking for is equal to the current value well then that means we found it and so we would return true if that wasn't the case then we need to keep looking so we set Cur equal to c. next and if this Loop ever concludes it means that we didn't find it and so we would return false at this level so let's just search for a few things here if we search for the value of two sorry you have to give that the head so search for head and two that is going to show up false we don't have that if you have nine that is also not the case if you have something that is in there like the head of one or the tail of seven clearly our search function works okay there's lots of exciting algorithms to learn about linked lists but you can learn those in the leak code problems okay now we're going to do doubly linked lists so for that again we'd have a class which is called doubly node so we have the forward and backward connection it takes a value that the node is going to be it takes a next pointer by default it's going to be none and it also has a previous which by default is going to be set to none okay then all it's going to do is just set the self. fou equal to the Past in fou and the next is going to be the next and the prieve is going to be the preve and we'll just give it a simple printing function so we'll Define underscore uncore string it's just going to return the string of the self. value the exact same as the previous okay then how we can work with this thing is you need access to both the head and the tail so we'll get head is equal to tail which is equal to a dou node and will give that the value of one if you print the head that should show you that the value is one and if you print the tail they're pointing to the same thing so this is also one so we'll Define a function call it display that takes just the head of the linked list you don't need the tail for this so we'll get Cur is equal to the head our elements is our list and again while we have cerr we want to elements. append the string of the C.V so exactly the same thing and we'd set c equal to c. next and then after we get out of here we just want to print with a different glue so we would print with the double connection like this implying we have forwards and backwards because we do so do join that up with the elements and if we were to run display just on our original head display the head we can see it's just one and that's totally accurate for now we just have one node so we want a function that inserts inserts at the beginning basically meaning getting a new head and that's going to be o of one so we'll Define a function called insert at beginning and that's going to take the head it's also going to take the tail and it's going to take the value that you want the new head to be so you would get a new node which is equal to a doubly node reference so we make a new node if you remember how our class looks here it is the value then next then previous so we want the value to be the value and we want to specifically specify that the next is equal to the head because it's saying that we're making a new node and we want that to be the value that we have we want this to point over to the Head the only thing we'd have to do here is set head. preve so our old head equal to the new node so before the head was basically pointing over to null because it was the head but now we want it to put in the middle pointing it to the new node we just made okay so we would return new node and the tail because this is our new head and the tail stay the same and then you would call this like with head and tail is equal to insert at beginning you'd give it the current head the current Tail as well as a new value and we'll give it the value of three so if we do that and then display our head well this is going to show that we have three at the beginning that made a new head and it points over to the one as the tail now if understanding this function was a little bit tricky that's the whole point of the lead code linked list problems is to get comfortable with drawing and then coding this idea okay similarly we could also do insert at end and I'm just kind of going to copy that and explain that for you we can insert at the end in O of one time where you give the head the tail and a new value you'd make a new node which is going to take that new value and you'd point that new node back over to the tail so that would point it left over to the old tail and then you would just need to update that your old tail is then going to point right over to your new node so this basically makes a new tail and so we'd return the head and the new tail and so if we were to run this with a value of seven we're going to see we have a new tail of seven okay as always you can get this code in the video description deson if you'd like to see it I hope this was helpful guys drop a like if it was and have a great day bye-bye
2025-07-11 03:19:10,864 - INFO - Transcript is successfully fetched by api.
2025-07-11 03:19:10,870 - INFO - Chunks has been successfully created.
2025-07-11 03:19:10,872 - INFO - Use pytorch device_name: cpu
2025-07-11 03:19:10,873 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-07-11 03:19:22,999 - INFO - chunks has been successfully stored in vector database.
2025-07-11 03:19:22,999 - INFO - {0: '8b6c2fe8-87d3-4779-800f-86d396d95cf2', 1: '137e57b5-63eb-47bd-a027-0ea397b93307', 2: 'ca1f39a2-b297-4b9f-a52c-a35562999e97', 3: 'e9c41330-2198-4374-aa96-8b494d3c6a3a', 4: '8476897b-477e-4c4d-a3e1-273a1905105a', 5: '215d97da-592e-4d8c-81e9-fa65e1b5ac09', 6: '624a0d23-7eba-41f9-bac8-ed3eede05727', 7: '86a3575f-3b8a-4b99-aa81-5deecb367a5b', 8: 'be8b2b27-3f8e-4034-9ea8-83c3815fe0cc', 9: 'ef9a6c53-c965-4085-8f58-00ea4161d33f', 10: 'f8004b48-be76-4fe5-a91f-dfa5664b8203', 11: 'f8010c09-0aa0-4c5f-9a71-9eca1c559702', 12: '6f54315a-15cf-411d-98cb-f32fdf3ccb46', 13: '3f86ed34-ce49-4fe2-a66f-33ab3e445186', 14: '83f2bc76-e12c-4f18-8741-187abead0361', 15: 'c417821f-4b43-484d-8479-42833de30206', 16: '70144e4f-a836-4b88-ba02-38ce696e3566', 17: '60e402e6-2b49-4031-bec8-87bd0fed26b3', 18: '653e49f3-8fc7-429a-b24f-9efdca80f4bf', 19: '357fbac2-91e3-4a31-8e6c-c7390e4724e2', 20: '81a746f7-2151-4695-b6cf-e2c058c45ae2', 21: '06b4f44b-1c93-41d2-825a-19e9bc80fc2f', 22: 'f1142210-d349-4883-918b-7182783f83ff', 23: '742de08d-976e-4a15-ae45-4266f9cdf60e', 24: '96d0ece0-895b-4843-a136-06b0d7cf4b7f', 25: 'babc29ef-933a-42e8-aa2a-a4f0c5e69708', 26: 'a278b509-89d5-40b1-b74b-3f2e7454bfd5', 27: 'd7ed51f5-fc00-4829-9f6e-e155202c1f87', 28: 'b83ae29a-f61e-4520-b84c-f2d1b1bf1ddd', 29: 'b336921b-143e-4e9e-b95b-118009c66115', 30: '172a5ec4-f526-4829-94a6-ac0f89658402', 31: 'c5ab8286-7892-4e94-838f-2623bce9fa59', 32: '58e32d72-3dbf-41ce-8422-dbd4490290c3', 33: '49f4b522-33d7-4056-8008-f2bcee582e50', 34: '1d69c5ee-720d-4fb6-b335-e8350adffb90', 35: '35cad5c2-aa38-42f4-a1ec-466236e6317d', 36: 'b044a3f8-8d44-408b-8982-b58a5a5856e4', 37: '487539ca-7346-46c7-9f81-81bf8bf8dd80', 38: 'dc14d806-dba1-4190-91c3-4943f0425dda', 39: 'ab3edee5-1ab5-4551-8fd0-234d7b0b9954', 40: '4253bf8a-a9df-402a-b997-b377e89cf04a', 41: '7a65c664-0d08-4d02-95b0-d46a637dc1da', 42: 'f9552696-58d2-4159-9574-220acf3efa62', 43: 'ca876e61-7872-4968-aaf7-4a72b3b62e30', 44: '8693e54d-67ae-4a28-aee5-d94bf73eeab6', 45: 'ee4e3bf6-4015-4e9b-82a6-18b643c56f42'}
2025-07-11 03:19:22,999 - INFO - length of chunks: 46
2025-07-11 03:19:23,001 - INFO - Retriever is working good.
2025-07-11 03:19:23,001 - INFO - 
 
 Token is: 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 
 

